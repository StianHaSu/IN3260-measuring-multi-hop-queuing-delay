/****************************************************************************
** Meta object code from reading C++ file 'qcustomplot.h'
**
** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "qcustomplot.h"
#include <QtGui/qtextcursor.h>
#include <QScreen>
#include <QtCore/qmetatype.h>
#include <QtCore/QList>

#if __has_include(<QtCore/qtmochelpers.h>)
#include <QtCore/qtmochelpers.h>
#else
QT_BEGIN_MOC_NAMESPACE
#endif


#include <memory>

#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'qcustomplot.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 68
#error "This file was generated using the moc from 6.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

#ifndef Q_CONSTINIT
#define Q_CONSTINIT
#endif

QT_WARNING_PUSH
QT_WARNING_DISABLE_DEPRECATED
QT_WARNING_DISABLE_GCC("-Wuseless-cast")
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPScatterStyleENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPScatterStyleENDCLASS = QtMocHelpers::stringData(
    "QCPScatterStyle",
    "ScatterShape",
    "ssNone",
    "ssDot",
    "ssCross",
    "ssPlus",
    "ssCircle",
    "ssDisc",
    "ssSquare",
    "ssDiamond",
    "ssStar",
    "ssTriangle",
    "ssTriangleInverted",
    "ssCrossSquare",
    "ssPlusSquare",
    "ssCrossCircle",
    "ssPlusCircle",
    "ssPeace",
    "ssPixmap",
    "ssCustom"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPScatterStyleENDCLASS_t {
    uint offsetsAndSizes[40];
    char stringdata0[16];
    char stringdata1[13];
    char stringdata2[7];
    char stringdata3[6];
    char stringdata4[8];
    char stringdata5[7];
    char stringdata6[9];
    char stringdata7[7];
    char stringdata8[9];
    char stringdata9[10];
    char stringdata10[7];
    char stringdata11[11];
    char stringdata12[19];
    char stringdata13[14];
    char stringdata14[13];
    char stringdata15[14];
    char stringdata16[13];
    char stringdata17[8];
    char stringdata18[9];
    char stringdata19[9];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPScatterStyleENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPScatterStyleENDCLASS_t qt_meta_stringdata_CLASSQCPScatterStyleENDCLASS = {
    {
        QT_MOC_LITERAL(0, 15),  // "QCPScatterStyle"
        QT_MOC_LITERAL(16, 12),  // "ScatterShape"
        QT_MOC_LITERAL(29, 6),  // "ssNone"
        QT_MOC_LITERAL(36, 5),  // "ssDot"
        QT_MOC_LITERAL(42, 7),  // "ssCross"
        QT_MOC_LITERAL(50, 6),  // "ssPlus"
        QT_MOC_LITERAL(57, 8),  // "ssCircle"
        QT_MOC_LITERAL(66, 6),  // "ssDisc"
        QT_MOC_LITERAL(73, 8),  // "ssSquare"
        QT_MOC_LITERAL(82, 9),  // "ssDiamond"
        QT_MOC_LITERAL(92, 6),  // "ssStar"
        QT_MOC_LITERAL(99, 10),  // "ssTriangle"
        QT_MOC_LITERAL(110, 18),  // "ssTriangleInverted"
        QT_MOC_LITERAL(129, 13),  // "ssCrossSquare"
        QT_MOC_LITERAL(143, 12),  // "ssPlusSquare"
        QT_MOC_LITERAL(156, 13),  // "ssCrossCircle"
        QT_MOC_LITERAL(170, 12),  // "ssPlusCircle"
        QT_MOC_LITERAL(183, 7),  // "ssPeace"
        QT_MOC_LITERAL(191, 8),  // "ssPixmap"
        QT_MOC_LITERAL(200, 8)   // "ssCustom"
    },
    "QCPScatterStyle",
    "ScatterShape",
    "ssNone",
    "ssDot",
    "ssCross",
    "ssPlus",
    "ssCircle",
    "ssDisc",
    "ssSquare",
    "ssDiamond",
    "ssStar",
    "ssTriangle",
    "ssTriangleInverted",
    "ssCrossSquare",
    "ssPlusSquare",
    "ssCrossCircle",
    "ssPlusCircle",
    "ssPeace",
    "ssPixmap",
    "ssCustom"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPScatterStyleENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       1,   14, // enums/sets
       0,    0, // constructors
       4,       // flags
       0,       // signalCount

 // enums: name, alias, flags, count, data
       1,    1, 0x0,   18,   19,

 // enum data: key, value
       2, uint(QCPScatterStyle::ssNone),
       3, uint(QCPScatterStyle::ssDot),
       4, uint(QCPScatterStyle::ssCross),
       5, uint(QCPScatterStyle::ssPlus),
       6, uint(QCPScatterStyle::ssCircle),
       7, uint(QCPScatterStyle::ssDisc),
       8, uint(QCPScatterStyle::ssSquare),
       9, uint(QCPScatterStyle::ssDiamond),
      10, uint(QCPScatterStyle::ssStar),
      11, uint(QCPScatterStyle::ssTriangle),
      12, uint(QCPScatterStyle::ssTriangleInverted),
      13, uint(QCPScatterStyle::ssCrossSquare),
      14, uint(QCPScatterStyle::ssPlusSquare),
      15, uint(QCPScatterStyle::ssCrossCircle),
      16, uint(QCPScatterStyle::ssPlusCircle),
      17, uint(QCPScatterStyle::ssPeace),
      18, uint(QCPScatterStyle::ssPixmap),
      19, uint(QCPScatterStyle::ssCustom),

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPScatterStyle::staticMetaObject = { {
    nullptr,
    qt_meta_stringdata_CLASSQCPScatterStyleENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPScatterStyleENDCLASS,
    nullptr,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPScatterStyleENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPScatterStyle, std::true_type>
    >,
    nullptr
} };

namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPPainterENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPPainterENDCLASS = QtMocHelpers::stringData(
    "QCPPainter",
    "PainterMode",
    "pmDefault",
    "pmVectorized",
    "pmNoCaching",
    "pmNonCosmetic",
    "PainterModes"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPPainterENDCLASS_t {
    uint offsetsAndSizes[14];
    char stringdata0[11];
    char stringdata1[12];
    char stringdata2[10];
    char stringdata3[13];
    char stringdata4[12];
    char stringdata5[14];
    char stringdata6[13];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPPainterENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPPainterENDCLASS_t qt_meta_stringdata_CLASSQCPPainterENDCLASS = {
    {
        QT_MOC_LITERAL(0, 10),  // "QCPPainter"
        QT_MOC_LITERAL(11, 11),  // "PainterMode"
        QT_MOC_LITERAL(23, 9),  // "pmDefault"
        QT_MOC_LITERAL(33, 12),  // "pmVectorized"
        QT_MOC_LITERAL(46, 11),  // "pmNoCaching"
        QT_MOC_LITERAL(58, 13),  // "pmNonCosmetic"
        QT_MOC_LITERAL(72, 12)   // "PainterModes"
    },
    "QCPPainter",
    "PainterMode",
    "pmDefault",
    "pmVectorized",
    "pmNoCaching",
    "pmNonCosmetic",
    "PainterModes"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPPainterENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       2,   14, // enums/sets
       0,    0, // constructors
       4,       // flags
       0,       // signalCount

 // enums: name, alias, flags, count, data
       1,    1, 0x1,    4,   24,
       6,    1, 0x1,    4,   32,

 // enum data: key, value
       2, uint(QCPPainter::pmDefault),
       3, uint(QCPPainter::pmVectorized),
       4, uint(QCPPainter::pmNoCaching),
       5, uint(QCPPainter::pmNonCosmetic),
       2, uint(QCPPainter::pmDefault),
       3, uint(QCPPainter::pmVectorized),
       4, uint(QCPPainter::pmNoCaching),
       5, uint(QCPPainter::pmNonCosmetic),

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPPainter::staticMetaObject = { {
    QtPrivate::MetaObjectForType<QPainter>::value,
    qt_meta_stringdata_CLASSQCPPainterENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPPainterENDCLASS,
    nullptr,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPPainterENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPPainter, std::true_type>
    >,
    nullptr
} };

namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPLayerENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPLayerENDCLASS = QtMocHelpers::stringData(
    "QCPLayer",
    "parentPlot",
    "QCustomPlot*",
    "name",
    "index",
    "children",
    "QList<QCPLayerable*>"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPLayerENDCLASS_t {
    uint offsetsAndSizes[14];
    char stringdata0[9];
    char stringdata1[11];
    char stringdata2[13];
    char stringdata3[5];
    char stringdata4[6];
    char stringdata5[9];
    char stringdata6[21];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPLayerENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPLayerENDCLASS_t qt_meta_stringdata_CLASSQCPLayerENDCLASS = {
    {
        QT_MOC_LITERAL(0, 8),  // "QCPLayer"
        QT_MOC_LITERAL(9, 10),  // "parentPlot"
        QT_MOC_LITERAL(20, 12),  // "QCustomPlot*"
        QT_MOC_LITERAL(33, 4),  // "name"
        QT_MOC_LITERAL(38, 5),  // "index"
        QT_MOC_LITERAL(44, 8),  // "children"
        QT_MOC_LITERAL(53, 20)   // "QList<QCPLayerable*>"
    },
    "QCPLayer",
    "parentPlot",
    "QCustomPlot*",
    "name",
    "index",
    "children",
    "QList<QCPLayerable*>"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPLayerENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       4,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, 0x80000000 | 2, 0x00015009, uint(-1), 0,
       3, QMetaType::QString, 0x00015001, uint(-1), 0,
       4, QMetaType::Int, 0x00015001, uint(-1), 0,
       5, 0x80000000 | 6, 0x00015009, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPLayer::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPLayerENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPLayerENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPLayerENDCLASS_t,
        // property 'parentPlot'
        QtPrivate::TypeAndForceComplete<QCustomPlot*, std::true_type>,
        // property 'name'
        QtPrivate::TypeAndForceComplete<QString, std::true_type>,
        // property 'index'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'children'
        QtPrivate::TypeAndForceComplete<QList<QCPLayerable*>, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPLayer, std::true_type>
    >,
    nullptr
} };

void QCPLayer::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 0:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCustomPlot* >(); break;
        case 3:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QList<QCPLayerable*> >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPLayer *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QCustomPlot**>(_v) = _t->parentPlot(); break;
        case 1: *reinterpret_cast< QString*>(_v) = _t->name(); break;
        case 2: *reinterpret_cast< int*>(_v) = _t->index(); break;
        case 3: *reinterpret_cast< QList<QCPLayerable*>*>(_v) = _t->children(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
}

const QMetaObject *QCPLayer::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPLayer::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPLayerENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int QCPLayer::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPLayerableENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPLayerableENDCLASS = QtMocHelpers::stringData(
    "QCPLayerable",
    "visible",
    "parentPlot",
    "QCustomPlot*",
    "parentLayerable",
    "QCPLayerable*",
    "layer",
    "QCPLayer*",
    "antialiased"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPLayerableENDCLASS_t {
    uint offsetsAndSizes[18];
    char stringdata0[13];
    char stringdata1[8];
    char stringdata2[11];
    char stringdata3[13];
    char stringdata4[16];
    char stringdata5[14];
    char stringdata6[6];
    char stringdata7[10];
    char stringdata8[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPLayerableENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPLayerableENDCLASS_t qt_meta_stringdata_CLASSQCPLayerableENDCLASS = {
    {
        QT_MOC_LITERAL(0, 12),  // "QCPLayerable"
        QT_MOC_LITERAL(13, 7),  // "visible"
        QT_MOC_LITERAL(21, 10),  // "parentPlot"
        QT_MOC_LITERAL(32, 12),  // "QCustomPlot*"
        QT_MOC_LITERAL(45, 15),  // "parentLayerable"
        QT_MOC_LITERAL(61, 13),  // "QCPLayerable*"
        QT_MOC_LITERAL(75, 5),  // "layer"
        QT_MOC_LITERAL(81, 9),  // "QCPLayer*"
        QT_MOC_LITERAL(91, 11)   // "antialiased"
    },
    "QCPLayerable",
    "visible",
    "parentPlot",
    "QCustomPlot*",
    "parentLayerable",
    "QCPLayerable*",
    "layer",
    "QCPLayer*",
    "antialiased"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPLayerableENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       5,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::Bool, 0x00015103, uint(-1), 0,
       2, 0x80000000 | 3, 0x00015009, uint(-1), 0,
       4, 0x80000000 | 5, 0x00015009, uint(-1), 0,
       6, 0x80000000 | 7, 0x0001510b, uint(-1), 0,
       8, QMetaType::Bool, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPLayerable::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPLayerableENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPLayerableENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPLayerableENDCLASS_t,
        // property 'visible'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'parentPlot'
        QtPrivate::TypeAndForceComplete<QCustomPlot*, std::true_type>,
        // property 'parentLayerable'
        QtPrivate::TypeAndForceComplete<QCPLayerable*, std::true_type>,
        // property 'layer'
        QtPrivate::TypeAndForceComplete<QCPLayer*, std::true_type>,
        // property 'antialiased'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPLayerable, std::true_type>
    >,
    nullptr
} };

void QCPLayerable::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 3:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPLayer* >(); break;
        case 2:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPLayerable* >(); break;
        case 1:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCustomPlot* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPLayerable *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< bool*>(_v) = _t->visible(); break;
        case 1: *reinterpret_cast< QCustomPlot**>(_v) = _t->parentPlot(); break;
        case 2: *reinterpret_cast< QCPLayerable**>(_v) = _t->parentLayerable(); break;
        case 3: *reinterpret_cast< QCPLayer**>(_v) = _t->layer(); break;
        case 4: *reinterpret_cast< bool*>(_v) = _t->antialiased(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPLayerable *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setVisible(*reinterpret_cast< bool*>(_v)); break;
        case 3: _t->setLayer(*reinterpret_cast< QCPLayer**>(_v)); break;
        case 4: _t->setAntialiased(*reinterpret_cast< bool*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
}

const QMetaObject *QCPLayerable::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPLayerable::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPLayerableENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int QCPLayerable::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS = QtMocHelpers::stringData(
    "QCPMarginGroup"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[15];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS_t qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS = {
    {
        QT_MOC_LITERAL(0, 14)   // "QCPMarginGroup"
    },
    "QCPMarginGroup"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPMarginGroupENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPMarginGroup::staticMetaObject = { {
    QMetaObject::SuperData::link<QObject::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPMarginGroupENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPMarginGroup, std::true_type>
    >,
    nullptr
} };

void QCPMarginGroup::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPMarginGroup::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPMarginGroup::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPMarginGroupENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int QCPMarginGroup::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS = QtMocHelpers::stringData(
    "QCPLayoutElement",
    "layout",
    "QCPLayout*",
    "rect",
    "outerRect",
    "margins",
    "QMargins",
    "minimumMargins",
    "minimumSize",
    "maximumSize"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS_t {
    uint offsetsAndSizes[20];
    char stringdata0[17];
    char stringdata1[7];
    char stringdata2[11];
    char stringdata3[5];
    char stringdata4[10];
    char stringdata5[8];
    char stringdata6[9];
    char stringdata7[15];
    char stringdata8[12];
    char stringdata9[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS_t qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS = {
    {
        QT_MOC_LITERAL(0, 16),  // "QCPLayoutElement"
        QT_MOC_LITERAL(17, 6),  // "layout"
        QT_MOC_LITERAL(24, 10),  // "QCPLayout*"
        QT_MOC_LITERAL(35, 4),  // "rect"
        QT_MOC_LITERAL(40, 9),  // "outerRect"
        QT_MOC_LITERAL(50, 7),  // "margins"
        QT_MOC_LITERAL(58, 8),  // "QMargins"
        QT_MOC_LITERAL(67, 14),  // "minimumMargins"
        QT_MOC_LITERAL(82, 11),  // "minimumSize"
        QT_MOC_LITERAL(94, 11)   // "maximumSize"
    },
    "QCPLayoutElement",
    "layout",
    "QCPLayout*",
    "rect",
    "outerRect",
    "margins",
    "QMargins",
    "minimumMargins",
    "minimumSize",
    "maximumSize"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPLayoutElementENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       7,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, 0x80000000 | 2, 0x00015009, uint(-1), 0,
       3, QMetaType::QRect, 0x00015001, uint(-1), 0,
       4, QMetaType::QRect, 0x00015103, uint(-1), 0,
       5, 0x80000000 | 6, 0x0001510b, uint(-1), 0,
       7, 0x80000000 | 6, 0x0001510b, uint(-1), 0,
       8, QMetaType::QSize, 0x00015103, uint(-1), 0,
       9, QMetaType::QSize, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPLayoutElement::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayerable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPLayoutElementENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS_t,
        // property 'layout'
        QtPrivate::TypeAndForceComplete<QCPLayout*, std::true_type>,
        // property 'rect'
        QtPrivate::TypeAndForceComplete<QRect, std::true_type>,
        // property 'outerRect'
        QtPrivate::TypeAndForceComplete<QRect, std::true_type>,
        // property 'margins'
        QtPrivate::TypeAndForceComplete<QMargins, std::true_type>,
        // property 'minimumMargins'
        QtPrivate::TypeAndForceComplete<QMargins, std::true_type>,
        // property 'minimumSize'
        QtPrivate::TypeAndForceComplete<QSize, std::true_type>,
        // property 'maximumSize'
        QtPrivate::TypeAndForceComplete<QSize, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPLayoutElement, std::true_type>
    >,
    nullptr
} };

void QCPLayoutElement::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 0:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPLayout* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPLayoutElement *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QCPLayout**>(_v) = _t->layout(); break;
        case 1: *reinterpret_cast< QRect*>(_v) = _t->rect(); break;
        case 2: *reinterpret_cast< QRect*>(_v) = _t->outerRect(); break;
        case 3: *reinterpret_cast< QMargins*>(_v) = _t->margins(); break;
        case 4: *reinterpret_cast< QMargins*>(_v) = _t->minimumMargins(); break;
        case 5: *reinterpret_cast< QSize*>(_v) = _t->minimumSize(); break;
        case 6: *reinterpret_cast< QSize*>(_v) = _t->maximumSize(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPLayoutElement *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 2: _t->setOuterRect(*reinterpret_cast< QRect*>(_v)); break;
        case 3: _t->setMargins(*reinterpret_cast< QMargins*>(_v)); break;
        case 4: _t->setMinimumMargins(*reinterpret_cast< QMargins*>(_v)); break;
        case 5: _t->setMinimumSize(*reinterpret_cast< QSize*>(_v)); break;
        case 6: _t->setMaximumSize(*reinterpret_cast< QSize*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
}

const QMetaObject *QCPLayoutElement::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPLayoutElement::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPLayoutElementENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayerable::qt_metacast(_clname);
}

int QCPLayoutElement::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayerable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 7;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPLayoutENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPLayoutENDCLASS = QtMocHelpers::stringData(
    "QCPLayout"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPLayoutENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[10];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPLayoutENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPLayoutENDCLASS_t qt_meta_stringdata_CLASSQCPLayoutENDCLASS = {
    {
        QT_MOC_LITERAL(0, 9)   // "QCPLayout"
    },
    "QCPLayout"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPLayoutENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPLayout::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayoutElement::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPLayoutENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPLayoutENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPLayoutENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPLayout, std::true_type>
    >,
    nullptr
} };

void QCPLayout::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPLayout::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPLayout::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPLayoutENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayoutElement::qt_metacast(_clname);
}

int QCPLayout::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayoutElement::qt_metacall(_c, _id, _a);
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS = QtMocHelpers::stringData(
    "QCPLayoutGrid",
    "rowCount",
    "columnCount",
    "columnStretchFactors",
    "QList<double>",
    "rowStretchFactors",
    "columnSpacing",
    "rowSpacing"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS_t {
    uint offsetsAndSizes[16];
    char stringdata0[14];
    char stringdata1[9];
    char stringdata2[12];
    char stringdata3[21];
    char stringdata4[14];
    char stringdata5[18];
    char stringdata6[14];
    char stringdata7[11];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS_t qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS = {
    {
        QT_MOC_LITERAL(0, 13),  // "QCPLayoutGrid"
        QT_MOC_LITERAL(14, 8),  // "rowCount"
        QT_MOC_LITERAL(23, 11),  // "columnCount"
        QT_MOC_LITERAL(35, 20),  // "columnStretchFactors"
        QT_MOC_LITERAL(56, 13),  // "QList<double>"
        QT_MOC_LITERAL(70, 17),  // "rowStretchFactors"
        QT_MOC_LITERAL(88, 13),  // "columnSpacing"
        QT_MOC_LITERAL(102, 10)   // "rowSpacing"
    },
    "QCPLayoutGrid",
    "rowCount",
    "columnCount",
    "columnStretchFactors",
    "QList<double>",
    "rowStretchFactors",
    "columnSpacing",
    "rowSpacing"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPLayoutGridENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       6,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::Int, 0x00015001, uint(-1), 0,
       2, QMetaType::Int, 0x00015001, uint(-1), 0,
       3, 0x80000000 | 4, 0x0001510b, uint(-1), 0,
       5, 0x80000000 | 4, 0x0001510b, uint(-1), 0,
       6, QMetaType::Int, 0x00015103, uint(-1), 0,
       7, QMetaType::Int, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPLayoutGrid::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayout::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPLayoutGridENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS_t,
        // property 'rowCount'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'columnCount'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'columnStretchFactors'
        QtPrivate::TypeAndForceComplete<QList<double>, std::true_type>,
        // property 'rowStretchFactors'
        QtPrivate::TypeAndForceComplete<QList<double>, std::true_type>,
        // property 'columnSpacing'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'rowSpacing'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPLayoutGrid, std::true_type>
    >,
    nullptr
} };

void QCPLayoutGrid::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 3:
        case 2:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QList<double> >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPLayoutGrid *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< int*>(_v) = _t->rowCount(); break;
        case 1: *reinterpret_cast< int*>(_v) = _t->columnCount(); break;
        case 2: *reinterpret_cast< QList<double>*>(_v) = _t->columnStretchFactors(); break;
        case 3: *reinterpret_cast< QList<double>*>(_v) = _t->rowStretchFactors(); break;
        case 4: *reinterpret_cast< int*>(_v) = _t->columnSpacing(); break;
        case 5: *reinterpret_cast< int*>(_v) = _t->rowSpacing(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPLayoutGrid *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 2: _t->setColumnStretchFactors(*reinterpret_cast< QList<double>*>(_v)); break;
        case 3: _t->setRowStretchFactors(*reinterpret_cast< QList<double>*>(_v)); break;
        case 4: _t->setColumnSpacing(*reinterpret_cast< int*>(_v)); break;
        case 5: _t->setRowSpacing(*reinterpret_cast< int*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
}

const QMetaObject *QCPLayoutGrid::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPLayoutGrid::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPLayoutGridENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayout::qt_metacast(_clname);
}

int QCPLayoutGrid::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayout::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 6;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS = QtMocHelpers::stringData(
    "QCPLayoutInset"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[15];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS_t qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS = {
    {
        QT_MOC_LITERAL(0, 14)   // "QCPLayoutInset"
    },
    "QCPLayoutInset"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPLayoutInsetENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPLayoutInset::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayout::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPLayoutInsetENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPLayoutInset, std::true_type>
    >,
    nullptr
} };

void QCPLayoutInset::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPLayoutInset::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPLayoutInset::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPLayoutInsetENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayout::qt_metacast(_clname);
}

int QCPLayoutInset::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayout::qt_metacall(_c, _id, _a);
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPLineEndingENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPLineEndingENDCLASS = QtMocHelpers::stringData(
    "QCPLineEnding",
    "EndingStyle",
    "esNone",
    "esFlatArrow",
    "esSpikeArrow",
    "esLineArrow",
    "esDisc",
    "esSquare",
    "esDiamond",
    "esBar",
    "esHalfBar",
    "esSkewedBar"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPLineEndingENDCLASS_t {
    uint offsetsAndSizes[24];
    char stringdata0[14];
    char stringdata1[12];
    char stringdata2[7];
    char stringdata3[12];
    char stringdata4[13];
    char stringdata5[12];
    char stringdata6[7];
    char stringdata7[9];
    char stringdata8[10];
    char stringdata9[6];
    char stringdata10[10];
    char stringdata11[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPLineEndingENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPLineEndingENDCLASS_t qt_meta_stringdata_CLASSQCPLineEndingENDCLASS = {
    {
        QT_MOC_LITERAL(0, 13),  // "QCPLineEnding"
        QT_MOC_LITERAL(14, 11),  // "EndingStyle"
        QT_MOC_LITERAL(26, 6),  // "esNone"
        QT_MOC_LITERAL(33, 11),  // "esFlatArrow"
        QT_MOC_LITERAL(45, 12),  // "esSpikeArrow"
        QT_MOC_LITERAL(58, 11),  // "esLineArrow"
        QT_MOC_LITERAL(70, 6),  // "esDisc"
        QT_MOC_LITERAL(77, 8),  // "esSquare"
        QT_MOC_LITERAL(86, 9),  // "esDiamond"
        QT_MOC_LITERAL(96, 5),  // "esBar"
        QT_MOC_LITERAL(102, 9),  // "esHalfBar"
        QT_MOC_LITERAL(112, 11)   // "esSkewedBar"
    },
    "QCPLineEnding",
    "EndingStyle",
    "esNone",
    "esFlatArrow",
    "esSpikeArrow",
    "esLineArrow",
    "esDisc",
    "esSquare",
    "esDiamond",
    "esBar",
    "esHalfBar",
    "esSkewedBar"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPLineEndingENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       1,   14, // enums/sets
       0,    0, // constructors
       4,       // flags
       0,       // signalCount

 // enums: name, alias, flags, count, data
       1,    1, 0x0,   10,   19,

 // enum data: key, value
       2, uint(QCPLineEnding::esNone),
       3, uint(QCPLineEnding::esFlatArrow),
       4, uint(QCPLineEnding::esSpikeArrow),
       5, uint(QCPLineEnding::esLineArrow),
       6, uint(QCPLineEnding::esDisc),
       7, uint(QCPLineEnding::esSquare),
       8, uint(QCPLineEnding::esDiamond),
       9, uint(QCPLineEnding::esBar),
      10, uint(QCPLineEnding::esHalfBar),
      11, uint(QCPLineEnding::esSkewedBar),

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPLineEnding::staticMetaObject = { {
    nullptr,
    qt_meta_stringdata_CLASSQCPLineEndingENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPLineEndingENDCLASS,
    nullptr,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPLineEndingENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPLineEnding, std::true_type>
    >,
    nullptr
} };

namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPGridENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPGridENDCLASS = QtMocHelpers::stringData(
    "QCPGrid",
    "subGridVisible",
    "antialiasedSubGrid",
    "antialiasedZeroLine",
    "pen",
    "subGridPen",
    "zeroLinePen"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPGridENDCLASS_t {
    uint offsetsAndSizes[14];
    char stringdata0[8];
    char stringdata1[15];
    char stringdata2[19];
    char stringdata3[20];
    char stringdata4[4];
    char stringdata5[11];
    char stringdata6[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPGridENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPGridENDCLASS_t qt_meta_stringdata_CLASSQCPGridENDCLASS = {
    {
        QT_MOC_LITERAL(0, 7),  // "QCPGrid"
        QT_MOC_LITERAL(8, 14),  // "subGridVisible"
        QT_MOC_LITERAL(23, 18),  // "antialiasedSubGrid"
        QT_MOC_LITERAL(42, 19),  // "antialiasedZeroLine"
        QT_MOC_LITERAL(62, 3),  // "pen"
        QT_MOC_LITERAL(66, 10),  // "subGridPen"
        QT_MOC_LITERAL(77, 11)   // "zeroLinePen"
    },
    "QCPGrid",
    "subGridVisible",
    "antialiasedSubGrid",
    "antialiasedZeroLine",
    "pen",
    "subGridPen",
    "zeroLinePen"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPGridENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       6,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::Bool, 0x00015103, uint(-1), 0,
       2, QMetaType::Bool, 0x00015103, uint(-1), 0,
       3, QMetaType::Bool, 0x00015103, uint(-1), 0,
       4, QMetaType::QPen, 0x00015103, uint(-1), 0,
       5, QMetaType::QPen, 0x00015103, uint(-1), 0,
       6, QMetaType::QPen, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPGrid::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayerable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPGridENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPGridENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPGridENDCLASS_t,
        // property 'subGridVisible'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'antialiasedSubGrid'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'antialiasedZeroLine'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'subGridPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'zeroLinePen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPGrid, std::true_type>
    >,
    nullptr
} };

void QCPGrid::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPGrid *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< bool*>(_v) = _t->subGridVisible(); break;
        case 1: *reinterpret_cast< bool*>(_v) = _t->antialiasedSubGrid(); break;
        case 2: *reinterpret_cast< bool*>(_v) = _t->antialiasedZeroLine(); break;
        case 3: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 4: *reinterpret_cast< QPen*>(_v) = _t->subGridPen(); break;
        case 5: *reinterpret_cast< QPen*>(_v) = _t->zeroLinePen(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPGrid *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setSubGridVisible(*reinterpret_cast< bool*>(_v)); break;
        case 1: _t->setAntialiasedSubGrid(*reinterpret_cast< bool*>(_v)); break;
        case 2: _t->setAntialiasedZeroLine(*reinterpret_cast< bool*>(_v)); break;
        case 3: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 4: _t->setSubGridPen(*reinterpret_cast< QPen*>(_v)); break;
        case 5: _t->setZeroLinePen(*reinterpret_cast< QPen*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPGrid::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPGrid::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPGridENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayerable::qt_metacast(_clname);
}

int QCPGrid::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayerable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 6;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPAxisENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPAxisENDCLASS = QtMocHelpers::stringData(
    "QCPAxis",
    "ticksRequest",
    "",
    "rangeChanged",
    "QCPRange",
    "newRange",
    "oldRange",
    "selectionChanged",
    "QCPAxis::SelectableParts",
    "parts",
    "setRange",
    "range",
    "setSelectableParts",
    "selectableParts",
    "setSelectedParts",
    "selectedParts",
    "axisType",
    "AxisType",
    "axisRect",
    "QCPAxisRect*",
    "scaleType",
    "ScaleType",
    "scaleLogBase",
    "rangeReversed",
    "autoTicks",
    "autoTickCount",
    "autoTickLabels",
    "autoTickStep",
    "autoSubTicks",
    "ticks",
    "tickLabels",
    "tickLabelPadding",
    "tickLabelType",
    "LabelType",
    "tickLabelFont",
    "tickLabelColor",
    "tickLabelRotation",
    "dateTimeFormat",
    "dateTimeSpec",
    "Qt::TimeSpec",
    "numberFormat",
    "numberPrecision",
    "tickStep",
    "tickVector",
    "QList<double>",
    "tickVectorLabels",
    "tickLengthIn",
    "tickLengthOut",
    "subTickCount",
    "subTickLengthIn",
    "subTickLengthOut",
    "basePen",
    "tickPen",
    "subTickPen",
    "labelFont",
    "labelColor",
    "label",
    "labelPadding",
    "padding",
    "offset",
    "SelectableParts",
    "selectedTickLabelFont",
    "selectedLabelFont",
    "selectedTickLabelColor",
    "selectedLabelColor",
    "selectedBasePen",
    "selectedTickPen",
    "selectedSubTickPen",
    "lowerEnding",
    "QCPLineEnding",
    "upperEnding",
    "grid",
    "QCPGrid*",
    "atLeft",
    "atRight",
    "atTop",
    "atBottom",
    "AxisTypes",
    "ltNumber",
    "ltDateTime",
    "stLinear",
    "stLogarithmic",
    "SelectablePart",
    "spNone",
    "spAxis",
    "spTickLabels",
    "spAxisLabel"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPAxisENDCLASS_t {
    uint offsetsAndSizes[174];
    char stringdata0[8];
    char stringdata1[13];
    char stringdata2[1];
    char stringdata3[13];
    char stringdata4[9];
    char stringdata5[9];
    char stringdata6[9];
    char stringdata7[17];
    char stringdata8[25];
    char stringdata9[6];
    char stringdata10[9];
    char stringdata11[6];
    char stringdata12[19];
    char stringdata13[16];
    char stringdata14[17];
    char stringdata15[14];
    char stringdata16[9];
    char stringdata17[9];
    char stringdata18[9];
    char stringdata19[13];
    char stringdata20[10];
    char stringdata21[10];
    char stringdata22[13];
    char stringdata23[14];
    char stringdata24[10];
    char stringdata25[14];
    char stringdata26[15];
    char stringdata27[13];
    char stringdata28[13];
    char stringdata29[6];
    char stringdata30[11];
    char stringdata31[17];
    char stringdata32[14];
    char stringdata33[10];
    char stringdata34[14];
    char stringdata35[15];
    char stringdata36[18];
    char stringdata37[15];
    char stringdata38[13];
    char stringdata39[13];
    char stringdata40[13];
    char stringdata41[16];
    char stringdata42[9];
    char stringdata43[11];
    char stringdata44[14];
    char stringdata45[17];
    char stringdata46[13];
    char stringdata47[14];
    char stringdata48[13];
    char stringdata49[16];
    char stringdata50[17];
    char stringdata51[8];
    char stringdata52[8];
    char stringdata53[11];
    char stringdata54[10];
    char stringdata55[11];
    char stringdata56[6];
    char stringdata57[13];
    char stringdata58[8];
    char stringdata59[7];
    char stringdata60[16];
    char stringdata61[22];
    char stringdata62[18];
    char stringdata63[23];
    char stringdata64[19];
    char stringdata65[16];
    char stringdata66[16];
    char stringdata67[19];
    char stringdata68[12];
    char stringdata69[14];
    char stringdata70[12];
    char stringdata71[5];
    char stringdata72[9];
    char stringdata73[7];
    char stringdata74[8];
    char stringdata75[6];
    char stringdata76[9];
    char stringdata77[10];
    char stringdata78[9];
    char stringdata79[11];
    char stringdata80[9];
    char stringdata81[14];
    char stringdata82[15];
    char stringdata83[7];
    char stringdata84[7];
    char stringdata85[13];
    char stringdata86[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPAxisENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPAxisENDCLASS_t qt_meta_stringdata_CLASSQCPAxisENDCLASS = {
    {
        QT_MOC_LITERAL(0, 7),  // "QCPAxis"
        QT_MOC_LITERAL(8, 12),  // "ticksRequest"
        QT_MOC_LITERAL(21, 0),  // ""
        QT_MOC_LITERAL(22, 12),  // "rangeChanged"
        QT_MOC_LITERAL(35, 8),  // "QCPRange"
        QT_MOC_LITERAL(44, 8),  // "newRange"
        QT_MOC_LITERAL(53, 8),  // "oldRange"
        QT_MOC_LITERAL(62, 16),  // "selectionChanged"
        QT_MOC_LITERAL(79, 24),  // "QCPAxis::SelectableParts"
        QT_MOC_LITERAL(104, 5),  // "parts"
        QT_MOC_LITERAL(110, 8),  // "setRange"
        QT_MOC_LITERAL(119, 5),  // "range"
        QT_MOC_LITERAL(125, 18),  // "setSelectableParts"
        QT_MOC_LITERAL(144, 15),  // "selectableParts"
        QT_MOC_LITERAL(160, 16),  // "setSelectedParts"
        QT_MOC_LITERAL(177, 13),  // "selectedParts"
        QT_MOC_LITERAL(191, 8),  // "axisType"
        QT_MOC_LITERAL(200, 8),  // "AxisType"
        QT_MOC_LITERAL(209, 8),  // "axisRect"
        QT_MOC_LITERAL(218, 12),  // "QCPAxisRect*"
        QT_MOC_LITERAL(231, 9),  // "scaleType"
        QT_MOC_LITERAL(241, 9),  // "ScaleType"
        QT_MOC_LITERAL(251, 12),  // "scaleLogBase"
        QT_MOC_LITERAL(264, 13),  // "rangeReversed"
        QT_MOC_LITERAL(278, 9),  // "autoTicks"
        QT_MOC_LITERAL(288, 13),  // "autoTickCount"
        QT_MOC_LITERAL(302, 14),  // "autoTickLabels"
        QT_MOC_LITERAL(317, 12),  // "autoTickStep"
        QT_MOC_LITERAL(330, 12),  // "autoSubTicks"
        QT_MOC_LITERAL(343, 5),  // "ticks"
        QT_MOC_LITERAL(349, 10),  // "tickLabels"
        QT_MOC_LITERAL(360, 16),  // "tickLabelPadding"
        QT_MOC_LITERAL(377, 13),  // "tickLabelType"
        QT_MOC_LITERAL(391, 9),  // "LabelType"
        QT_MOC_LITERAL(401, 13),  // "tickLabelFont"
        QT_MOC_LITERAL(415, 14),  // "tickLabelColor"
        QT_MOC_LITERAL(430, 17),  // "tickLabelRotation"
        QT_MOC_LITERAL(448, 14),  // "dateTimeFormat"
        QT_MOC_LITERAL(463, 12),  // "dateTimeSpec"
        QT_MOC_LITERAL(476, 12),  // "Qt::TimeSpec"
        QT_MOC_LITERAL(489, 12),  // "numberFormat"
        QT_MOC_LITERAL(502, 15),  // "numberPrecision"
        QT_MOC_LITERAL(518, 8),  // "tickStep"
        QT_MOC_LITERAL(527, 10),  // "tickVector"
        QT_MOC_LITERAL(538, 13),  // "QList<double>"
        QT_MOC_LITERAL(552, 16),  // "tickVectorLabels"
        QT_MOC_LITERAL(569, 12),  // "tickLengthIn"
        QT_MOC_LITERAL(582, 13),  // "tickLengthOut"
        QT_MOC_LITERAL(596, 12),  // "subTickCount"
        QT_MOC_LITERAL(609, 15),  // "subTickLengthIn"
        QT_MOC_LITERAL(625, 16),  // "subTickLengthOut"
        QT_MOC_LITERAL(642, 7),  // "basePen"
        QT_MOC_LITERAL(650, 7),  // "tickPen"
        QT_MOC_LITERAL(658, 10),  // "subTickPen"
        QT_MOC_LITERAL(669, 9),  // "labelFont"
        QT_MOC_LITERAL(679, 10),  // "labelColor"
        QT_MOC_LITERAL(690, 5),  // "label"
        QT_MOC_LITERAL(696, 12),  // "labelPadding"
        QT_MOC_LITERAL(709, 7),  // "padding"
        QT_MOC_LITERAL(717, 6),  // "offset"
        QT_MOC_LITERAL(724, 15),  // "SelectableParts"
        QT_MOC_LITERAL(740, 21),  // "selectedTickLabelFont"
        QT_MOC_LITERAL(762, 17),  // "selectedLabelFont"
        QT_MOC_LITERAL(780, 22),  // "selectedTickLabelColor"
        QT_MOC_LITERAL(803, 18),  // "selectedLabelColor"
        QT_MOC_LITERAL(822, 15),  // "selectedBasePen"
        QT_MOC_LITERAL(838, 15),  // "selectedTickPen"
        QT_MOC_LITERAL(854, 18),  // "selectedSubTickPen"
        QT_MOC_LITERAL(873, 11),  // "lowerEnding"
        QT_MOC_LITERAL(885, 13),  // "QCPLineEnding"
        QT_MOC_LITERAL(899, 11),  // "upperEnding"
        QT_MOC_LITERAL(911, 4),  // "grid"
        QT_MOC_LITERAL(916, 8),  // "QCPGrid*"
        QT_MOC_LITERAL(925, 6),  // "atLeft"
        QT_MOC_LITERAL(932, 7),  // "atRight"
        QT_MOC_LITERAL(940, 5),  // "atTop"
        QT_MOC_LITERAL(946, 8),  // "atBottom"
        QT_MOC_LITERAL(955, 9),  // "AxisTypes"
        QT_MOC_LITERAL(965, 8),  // "ltNumber"
        QT_MOC_LITERAL(974, 10),  // "ltDateTime"
        QT_MOC_LITERAL(985, 8),  // "stLinear"
        QT_MOC_LITERAL(994, 13),  // "stLogarithmic"
        QT_MOC_LITERAL(1008, 14),  // "SelectablePart"
        QT_MOC_LITERAL(1023, 6),  // "spNone"
        QT_MOC_LITERAL(1030, 6),  // "spAxis"
        QT_MOC_LITERAL(1037, 12),  // "spTickLabels"
        QT_MOC_LITERAL(1050, 11)   // "spAxisLabel"
    },
    "QCPAxis",
    "ticksRequest",
    "",
    "rangeChanged",
    "QCPRange",
    "newRange",
    "oldRange",
    "selectionChanged",
    "QCPAxis::SelectableParts",
    "parts",
    "setRange",
    "range",
    "setSelectableParts",
    "selectableParts",
    "setSelectedParts",
    "selectedParts",
    "axisType",
    "AxisType",
    "axisRect",
    "QCPAxisRect*",
    "scaleType",
    "ScaleType",
    "scaleLogBase",
    "rangeReversed",
    "autoTicks",
    "autoTickCount",
    "autoTickLabels",
    "autoTickStep",
    "autoSubTicks",
    "ticks",
    "tickLabels",
    "tickLabelPadding",
    "tickLabelType",
    "LabelType",
    "tickLabelFont",
    "tickLabelColor",
    "tickLabelRotation",
    "dateTimeFormat",
    "dateTimeSpec",
    "Qt::TimeSpec",
    "numberFormat",
    "numberPrecision",
    "tickStep",
    "tickVector",
    "QList<double>",
    "tickVectorLabels",
    "tickLengthIn",
    "tickLengthOut",
    "subTickCount",
    "subTickLengthIn",
    "subTickLengthOut",
    "basePen",
    "tickPen",
    "subTickPen",
    "labelFont",
    "labelColor",
    "label",
    "labelPadding",
    "padding",
    "offset",
    "SelectableParts",
    "selectedTickLabelFont",
    "selectedLabelFont",
    "selectedTickLabelColor",
    "selectedLabelColor",
    "selectedBasePen",
    "selectedTickPen",
    "selectedSubTickPen",
    "lowerEnding",
    "QCPLineEnding",
    "upperEnding",
    "grid",
    "QCPGrid*",
    "atLeft",
    "atRight",
    "atTop",
    "atBottom",
    "AxisTypes",
    "ltNumber",
    "ltDateTime",
    "stLinear",
    "stLogarithmic",
    "SelectablePart",
    "spNone",
    "spAxis",
    "spTickLabels",
    "spAxisLabel"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPAxisENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       7,   14, // methods
      51,   77, // properties
       6,  332, // enums/sets
       0,    0, // constructors
       0,       // flags
       4,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    0,   56,    2, 0x06,   52 /* Public */,
       3,    1,   57,    2, 0x06,   53 /* Public */,
       3,    2,   60,    2, 0x06,   55 /* Public */,
       7,    1,   65,    2, 0x06,   58 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
      10,    1,   68,    2, 0x0a,   60 /* Public */,
      12,    1,   71,    2, 0x0a,   62 /* Public */,
      14,    1,   74,    2, 0x0a,   64 /* Public */,

 // signals: parameters
    QMetaType::Void,
    QMetaType::Void, 0x80000000 | 4,    5,
    QMetaType::Void, 0x80000000 | 4, 0x80000000 | 4,    5,    6,
    QMetaType::Void, 0x80000000 | 8,    9,

 // slots: parameters
    QMetaType::Void, 0x80000000 | 4,   11,
    QMetaType::Void, 0x80000000 | 8,   13,
    QMetaType::Void, 0x80000000 | 8,   15,

 // properties: name, type, flags
      16, 0x80000000 | 17, 0x00015009, uint(-1), 0,
      18, 0x80000000 | 19, 0x00015009, uint(-1), 0,
      20, 0x80000000 | 21, 0x0001510b, uint(-1), 0,
      22, QMetaType::Double, 0x00015103, uint(-1), 0,
      11, 0x80000000 | 4, 0x0001510b, uint(-1), 0,
      23, QMetaType::Bool, 0x00015103, uint(-1), 0,
      24, QMetaType::Bool, 0x00015103, uint(-1), 0,
      25, QMetaType::Int, 0x00015103, uint(-1), 0,
      26, QMetaType::Bool, 0x00015103, uint(-1), 0,
      27, QMetaType::Bool, 0x00015103, uint(-1), 0,
      28, QMetaType::Bool, 0x00015103, uint(-1), 0,
      29, QMetaType::Bool, 0x00015103, uint(-1), 0,
      30, QMetaType::Bool, 0x00015103, uint(-1), 0,
      31, QMetaType::Int, 0x00015103, uint(-1), 0,
      32, 0x80000000 | 33, 0x0001510b, uint(-1), 0,
      34, QMetaType::QFont, 0x00015103, uint(-1), 0,
      35, QMetaType::QColor, 0x00015103, uint(-1), 0,
      36, QMetaType::Double, 0x00015103, uint(-1), 0,
      37, QMetaType::QString, 0x00015103, uint(-1), 0,
      38, 0x80000000 | 39, 0x0001510b, uint(-1), 0,
      40, QMetaType::QString, 0x00015103, uint(-1), 0,
      41, QMetaType::Int, 0x00015103, uint(-1), 0,
      42, QMetaType::Double, 0x00015103, uint(-1), 0,
      43, 0x80000000 | 44, 0x0001510b, uint(-1), 0,
      45, QMetaType::QStringList, 0x00015103, uint(-1), 0,
      46, QMetaType::Int, 0x00015103, uint(-1), 0,
      47, QMetaType::Int, 0x00015103, uint(-1), 0,
      48, QMetaType::Int, 0x00015103, uint(-1), 0,
      49, QMetaType::Int, 0x00015103, uint(-1), 0,
      50, QMetaType::Int, 0x00015103, uint(-1), 0,
      51, QMetaType::QPen, 0x00015103, uint(-1), 0,
      52, QMetaType::QPen, 0x00015103, uint(-1), 0,
      53, QMetaType::QPen, 0x00015103, uint(-1), 0,
      54, QMetaType::QFont, 0x00015103, uint(-1), 0,
      55, QMetaType::QColor, 0x00015103, uint(-1), 0,
      56, QMetaType::QString, 0x00015103, uint(-1), 0,
      57, QMetaType::Int, 0x00015103, uint(-1), 0,
      58, QMetaType::Int, 0x00015103, uint(-1), 0,
      59, QMetaType::Int, 0x00015103, uint(-1), 0,
      15, 0x80000000 | 60, 0x0001510b, uint(-1), 0,
      13, 0x80000000 | 60, 0x0001510b, uint(-1), 0,
      61, QMetaType::QFont, 0x00015103, uint(-1), 0,
      62, QMetaType::QFont, 0x00015103, uint(-1), 0,
      63, QMetaType::QColor, 0x00015103, uint(-1), 0,
      64, QMetaType::QColor, 0x00015103, uint(-1), 0,
      65, QMetaType::QPen, 0x00015103, uint(-1), 0,
      66, QMetaType::QPen, 0x00015103, uint(-1), 0,
      67, QMetaType::QPen, 0x00015103, uint(-1), 0,
      68, 0x80000000 | 69, 0x0001510b, uint(-1), 0,
      70, 0x80000000 | 69, 0x0001510b, uint(-1), 0,
      71, 0x80000000 | 72, 0x00015009, uint(-1), 0,

 // enums: name, alias, flags, count, data
      17,   17, 0x1,    4,  362,
      77,   17, 0x1,    4,  370,
      33,   33, 0x0,    2,  378,
      21,   21, 0x0,    2,  382,
      82,   82, 0x1,    4,  386,
      60,   82, 0x1,    4,  394,

 // enum data: key, value
      73, uint(QCPAxis::atLeft),
      74, uint(QCPAxis::atRight),
      75, uint(QCPAxis::atTop),
      76, uint(QCPAxis::atBottom),
      73, uint(QCPAxis::atLeft),
      74, uint(QCPAxis::atRight),
      75, uint(QCPAxis::atTop),
      76, uint(QCPAxis::atBottom),
      78, uint(QCPAxis::ltNumber),
      79, uint(QCPAxis::ltDateTime),
      80, uint(QCPAxis::stLinear),
      81, uint(QCPAxis::stLogarithmic),
      83, uint(QCPAxis::spNone),
      84, uint(QCPAxis::spAxis),
      85, uint(QCPAxis::spTickLabels),
      86, uint(QCPAxis::spAxisLabel),
      83, uint(QCPAxis::spNone),
      84, uint(QCPAxis::spAxis),
      85, uint(QCPAxis::spTickLabels),
      86, uint(QCPAxis::spAxisLabel),

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPAxis::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayerable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPAxisENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPAxisENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPAxisENDCLASS_t,
        // property 'axisType'
        QtPrivate::TypeAndForceComplete<AxisType, std::true_type>,
        // property 'axisRect'
        QtPrivate::TypeAndForceComplete<QCPAxisRect*, std::true_type>,
        // property 'scaleType'
        QtPrivate::TypeAndForceComplete<ScaleType, std::true_type>,
        // property 'scaleLogBase'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'range'
        QtPrivate::TypeAndForceComplete<QCPRange, std::true_type>,
        // property 'rangeReversed'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'autoTicks'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'autoTickCount'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'autoTickLabels'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'autoTickStep'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'autoSubTicks'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'ticks'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'tickLabels'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'tickLabelPadding'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'tickLabelType'
        QtPrivate::TypeAndForceComplete<LabelType, std::true_type>,
        // property 'tickLabelFont'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'tickLabelColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'tickLabelRotation'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'dateTimeFormat'
        QtPrivate::TypeAndForceComplete<QString, std::true_type>,
        // property 'dateTimeSpec'
        QtPrivate::TypeAndForceComplete<Qt::TimeSpec, std::true_type>,
        // property 'numberFormat'
        QtPrivate::TypeAndForceComplete<QString, std::true_type>,
        // property 'numberPrecision'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'tickStep'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'tickVector'
        QtPrivate::TypeAndForceComplete<QList<double>, std::true_type>,
        // property 'tickVectorLabels'
        QtPrivate::TypeAndForceComplete<QList<QString>, std::true_type>,
        // property 'tickLengthIn'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'tickLengthOut'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'subTickCount'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'subTickLengthIn'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'subTickLengthOut'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'basePen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'tickPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'subTickPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'labelFont'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'labelColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'label'
        QtPrivate::TypeAndForceComplete<QString, std::true_type>,
        // property 'labelPadding'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'padding'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'offset'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'selectedParts'
        QtPrivate::TypeAndForceComplete<SelectableParts, std::true_type>,
        // property 'selectableParts'
        QtPrivate::TypeAndForceComplete<SelectableParts, std::true_type>,
        // property 'selectedTickLabelFont'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'selectedLabelFont'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'selectedTickLabelColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'selectedLabelColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'selectedBasePen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedTickPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedSubTickPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'lowerEnding'
        QtPrivate::TypeAndForceComplete<QCPLineEnding, std::true_type>,
        // property 'upperEnding'
        QtPrivate::TypeAndForceComplete<QCPLineEnding, std::true_type>,
        // property 'grid'
        QtPrivate::TypeAndForceComplete<QCPGrid*, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPAxis, std::true_type>,
        // method 'ticksRequest'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'rangeChanged'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QCPRange &, std::false_type>,
        // method 'rangeChanged'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QCPRange &, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QCPRange &, std::false_type>,
        // method 'selectionChanged'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QCPAxis::SelectableParts &, std::false_type>,
        // method 'setRange'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QCPRange &, std::false_type>,
        // method 'setSelectableParts'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QCPAxis::SelectableParts &, std::false_type>,
        // method 'setSelectedParts'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<const QCPAxis::SelectableParts &, std::false_type>
    >,
    nullptr
} };

void QCPAxis::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<QCPAxis *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->ticksRequest(); break;
        case 1: _t->rangeChanged((*reinterpret_cast< std::add_pointer_t<QCPRange>>(_a[1]))); break;
        case 2: _t->rangeChanged((*reinterpret_cast< std::add_pointer_t<QCPRange>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QCPRange>>(_a[2]))); break;
        case 3: _t->selectionChanged((*reinterpret_cast< std::add_pointer_t<QCPAxis::SelectableParts>>(_a[1]))); break;
        case 4: _t->setRange((*reinterpret_cast< std::add_pointer_t<QCPRange>>(_a[1]))); break;
        case 5: _t->setSelectableParts((*reinterpret_cast< std::add_pointer_t<QCPAxis::SelectableParts>>(_a[1]))); break;
        case 6: _t->setSelectedParts((*reinterpret_cast< std::add_pointer_t<QCPAxis::SelectableParts>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (QCPAxis::*)();
            if (_t _q_method = &QCPAxis::ticksRequest; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (QCPAxis::*)(const QCPRange & );
            if (_t _q_method = &QCPAxis::rangeChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (QCPAxis::*)(const QCPRange & , const QCPRange & );
            if (_t _q_method = &QCPAxis::rangeChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (QCPAxis::*)(const QCPAxis::SelectableParts & );
            if (_t _q_method = &QCPAxis::selectionChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 3;
                return;
            }
        }
    } else if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 1:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPAxisRect* >(); break;
        case 50:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPGrid* >(); break;
        case 23:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QList<double> >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPAxis *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast<int*>(_v) = QFlag(_t->axisType()); break;
        case 1: *reinterpret_cast< QCPAxisRect**>(_v) = _t->axisRect(); break;
        case 2: *reinterpret_cast< ScaleType*>(_v) = _t->scaleType(); break;
        case 3: *reinterpret_cast< double*>(_v) = _t->scaleLogBase(); break;
        case 4: *reinterpret_cast< QCPRange*>(_v) = _t->range(); break;
        case 5: *reinterpret_cast< bool*>(_v) = _t->rangeReversed(); break;
        case 6: *reinterpret_cast< bool*>(_v) = _t->autoTicks(); break;
        case 7: *reinterpret_cast< int*>(_v) = _t->autoTickCount(); break;
        case 8: *reinterpret_cast< bool*>(_v) = _t->autoTickLabels(); break;
        case 9: *reinterpret_cast< bool*>(_v) = _t->autoTickStep(); break;
        case 10: *reinterpret_cast< bool*>(_v) = _t->autoSubTicks(); break;
        case 11: *reinterpret_cast< bool*>(_v) = _t->ticks(); break;
        case 12: *reinterpret_cast< bool*>(_v) = _t->tickLabels(); break;
        case 13: *reinterpret_cast< int*>(_v) = _t->tickLabelPadding(); break;
        case 14: *reinterpret_cast< LabelType*>(_v) = _t->tickLabelType(); break;
        case 15: *reinterpret_cast< QFont*>(_v) = _t->tickLabelFont(); break;
        case 16: *reinterpret_cast< QColor*>(_v) = _t->tickLabelColor(); break;
        case 17: *reinterpret_cast< double*>(_v) = _t->tickLabelRotation(); break;
        case 18: *reinterpret_cast< QString*>(_v) = _t->dateTimeFormat(); break;
        case 19: *reinterpret_cast< Qt::TimeSpec*>(_v) = _t->dateTimeSpec(); break;
        case 20: *reinterpret_cast< QString*>(_v) = _t->numberFormat(); break;
        case 21: *reinterpret_cast< int*>(_v) = _t->numberPrecision(); break;
        case 22: *reinterpret_cast< double*>(_v) = _t->tickStep(); break;
        case 23: *reinterpret_cast< QList<double>*>(_v) = _t->tickVector(); break;
        case 24: *reinterpret_cast< QList<QString>*>(_v) = _t->tickVectorLabels(); break;
        case 25: *reinterpret_cast< int*>(_v) = _t->tickLengthIn(); break;
        case 26: *reinterpret_cast< int*>(_v) = _t->tickLengthOut(); break;
        case 27: *reinterpret_cast< int*>(_v) = _t->subTickCount(); break;
        case 28: *reinterpret_cast< int*>(_v) = _t->subTickLengthIn(); break;
        case 29: *reinterpret_cast< int*>(_v) = _t->subTickLengthOut(); break;
        case 30: *reinterpret_cast< QPen*>(_v) = _t->basePen(); break;
        case 31: *reinterpret_cast< QPen*>(_v) = _t->tickPen(); break;
        case 32: *reinterpret_cast< QPen*>(_v) = _t->subTickPen(); break;
        case 33: *reinterpret_cast< QFont*>(_v) = _t->labelFont(); break;
        case 34: *reinterpret_cast< QColor*>(_v) = _t->labelColor(); break;
        case 35: *reinterpret_cast< QString*>(_v) = _t->label(); break;
        case 36: *reinterpret_cast< int*>(_v) = _t->labelPadding(); break;
        case 37: *reinterpret_cast< int*>(_v) = _t->padding(); break;
        case 38: *reinterpret_cast< int*>(_v) = _t->offset(); break;
        case 39: *reinterpret_cast<int*>(_v) = QFlag(_t->selectedParts()); break;
        case 40: *reinterpret_cast<int*>(_v) = QFlag(_t->selectableParts()); break;
        case 41: *reinterpret_cast< QFont*>(_v) = _t->selectedTickLabelFont(); break;
        case 42: *reinterpret_cast< QFont*>(_v) = _t->selectedLabelFont(); break;
        case 43: *reinterpret_cast< QColor*>(_v) = _t->selectedTickLabelColor(); break;
        case 44: *reinterpret_cast< QColor*>(_v) = _t->selectedLabelColor(); break;
        case 45: *reinterpret_cast< QPen*>(_v) = _t->selectedBasePen(); break;
        case 46: *reinterpret_cast< QPen*>(_v) = _t->selectedTickPen(); break;
        case 47: *reinterpret_cast< QPen*>(_v) = _t->selectedSubTickPen(); break;
        case 48: *reinterpret_cast< QCPLineEnding*>(_v) = _t->lowerEnding(); break;
        case 49: *reinterpret_cast< QCPLineEnding*>(_v) = _t->upperEnding(); break;
        case 50: *reinterpret_cast< QCPGrid**>(_v) = _t->grid(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPAxis *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 2: _t->setScaleType(*reinterpret_cast< ScaleType*>(_v)); break;
        case 3: _t->setScaleLogBase(*reinterpret_cast< double*>(_v)); break;
        case 4: _t->setRange(*reinterpret_cast< QCPRange*>(_v)); break;
        case 5: _t->setRangeReversed(*reinterpret_cast< bool*>(_v)); break;
        case 6: _t->setAutoTicks(*reinterpret_cast< bool*>(_v)); break;
        case 7: _t->setAutoTickCount(*reinterpret_cast< int*>(_v)); break;
        case 8: _t->setAutoTickLabels(*reinterpret_cast< bool*>(_v)); break;
        case 9: _t->setAutoTickStep(*reinterpret_cast< bool*>(_v)); break;
        case 10: _t->setAutoSubTicks(*reinterpret_cast< bool*>(_v)); break;
        case 11: _t->setTicks(*reinterpret_cast< bool*>(_v)); break;
        case 12: _t->setTickLabels(*reinterpret_cast< bool*>(_v)); break;
        case 13: _t->setTickLabelPadding(*reinterpret_cast< int*>(_v)); break;
        case 14: _t->setTickLabelType(*reinterpret_cast< LabelType*>(_v)); break;
        case 15: _t->setTickLabelFont(*reinterpret_cast< QFont*>(_v)); break;
        case 16: _t->setTickLabelColor(*reinterpret_cast< QColor*>(_v)); break;
        case 17: _t->setTickLabelRotation(*reinterpret_cast< double*>(_v)); break;
        case 18: _t->setDateTimeFormat(*reinterpret_cast< QString*>(_v)); break;
        case 19: _t->setDateTimeSpec(*reinterpret_cast< Qt::TimeSpec*>(_v)); break;
        case 20: _t->setNumberFormat(*reinterpret_cast< QString*>(_v)); break;
        case 21: _t->setNumberPrecision(*reinterpret_cast< int*>(_v)); break;
        case 22: _t->setTickStep(*reinterpret_cast< double*>(_v)); break;
        case 23: _t->setTickVector(*reinterpret_cast< QList<double>*>(_v)); break;
        case 24: _t->setTickVectorLabels(*reinterpret_cast< QList<QString>*>(_v)); break;
        case 25: _t->setTickLengthIn(*reinterpret_cast< int*>(_v)); break;
        case 26: _t->setTickLengthOut(*reinterpret_cast< int*>(_v)); break;
        case 27: _t->setSubTickCount(*reinterpret_cast< int*>(_v)); break;
        case 28: _t->setSubTickLengthIn(*reinterpret_cast< int*>(_v)); break;
        case 29: _t->setSubTickLengthOut(*reinterpret_cast< int*>(_v)); break;
        case 30: _t->setBasePen(*reinterpret_cast< QPen*>(_v)); break;
        case 31: _t->setTickPen(*reinterpret_cast< QPen*>(_v)); break;
        case 32: _t->setSubTickPen(*reinterpret_cast< QPen*>(_v)); break;
        case 33: _t->setLabelFont(*reinterpret_cast< QFont*>(_v)); break;
        case 34: _t->setLabelColor(*reinterpret_cast< QColor*>(_v)); break;
        case 35: _t->setLabel(*reinterpret_cast< QString*>(_v)); break;
        case 36: _t->setLabelPadding(*reinterpret_cast< int*>(_v)); break;
        case 37: _t->setPadding(*reinterpret_cast< int*>(_v)); break;
        case 38: _t->setOffset(*reinterpret_cast< int*>(_v)); break;
        case 39: _t->setSelectedParts(QFlag(*reinterpret_cast<int*>(_v))); break;
        case 40: _t->setSelectableParts(QFlag(*reinterpret_cast<int*>(_v))); break;
        case 41: _t->setSelectedTickLabelFont(*reinterpret_cast< QFont*>(_v)); break;
        case 42: _t->setSelectedLabelFont(*reinterpret_cast< QFont*>(_v)); break;
        case 43: _t->setSelectedTickLabelColor(*reinterpret_cast< QColor*>(_v)); break;
        case 44: _t->setSelectedLabelColor(*reinterpret_cast< QColor*>(_v)); break;
        case 45: _t->setSelectedBasePen(*reinterpret_cast< QPen*>(_v)); break;
        case 46: _t->setSelectedTickPen(*reinterpret_cast< QPen*>(_v)); break;
        case 47: _t->setSelectedSubTickPen(*reinterpret_cast< QPen*>(_v)); break;
        case 48: _t->setLowerEnding(*reinterpret_cast< QCPLineEnding*>(_v)); break;
        case 49: _t->setUpperEnding(*reinterpret_cast< QCPLineEnding*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
}

const QMetaObject *QCPAxis::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPAxis::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPAxisENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayerable::qt_metacast(_clname);
}

int QCPAxis::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayerable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 7)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 7;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 7)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 7;
    }else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 51;
    }
    return _id;
}

// SIGNAL 0
void QCPAxis::ticksRequest()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}

// SIGNAL 1
void QCPAxis::rangeChanged(const QCPRange & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void QCPAxis::rangeChanged(const QCPRange & _t1, const QCPRange & _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void QCPAxis::selectionChanged(const QCPAxis::SelectableParts & _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS = QtMocHelpers::stringData(
    "QCPAbstractPlottable",
    "selectionChanged",
    "",
    "selected",
    "setSelectable",
    "selectable",
    "setSelected",
    "name",
    "antialiasedFill",
    "antialiasedScatters",
    "antialiasedErrorBars",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush",
    "keyAxis",
    "QCPAxis*",
    "valueAxis"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS_t {
    uint offsetsAndSizes[36];
    char stringdata0[21];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[9];
    char stringdata4[14];
    char stringdata5[11];
    char stringdata6[12];
    char stringdata7[5];
    char stringdata8[16];
    char stringdata9[20];
    char stringdata10[21];
    char stringdata11[4];
    char stringdata12[12];
    char stringdata13[6];
    char stringdata14[14];
    char stringdata15[8];
    char stringdata16[9];
    char stringdata17[10];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS_t qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS = {
    {
        QT_MOC_LITERAL(0, 20),  // "QCPAbstractPlottable"
        QT_MOC_LITERAL(21, 16),  // "selectionChanged"
        QT_MOC_LITERAL(38, 0),  // ""
        QT_MOC_LITERAL(39, 8),  // "selected"
        QT_MOC_LITERAL(48, 13),  // "setSelectable"
        QT_MOC_LITERAL(62, 10),  // "selectable"
        QT_MOC_LITERAL(73, 11),  // "setSelected"
        QT_MOC_LITERAL(85, 4),  // "name"
        QT_MOC_LITERAL(90, 15),  // "antialiasedFill"
        QT_MOC_LITERAL(106, 19),  // "antialiasedScatters"
        QT_MOC_LITERAL(126, 20),  // "antialiasedErrorBars"
        QT_MOC_LITERAL(147, 3),  // "pen"
        QT_MOC_LITERAL(151, 11),  // "selectedPen"
        QT_MOC_LITERAL(163, 5),  // "brush"
        QT_MOC_LITERAL(169, 13),  // "selectedBrush"
        QT_MOC_LITERAL(183, 7),  // "keyAxis"
        QT_MOC_LITERAL(191, 8),  // "QCPAxis*"
        QT_MOC_LITERAL(200, 9)   // "valueAxis"
    },
    "QCPAbstractPlottable",
    "selectionChanged",
    "",
    "selected",
    "setSelectable",
    "selectable",
    "setSelected",
    "name",
    "antialiasedFill",
    "antialiasedScatters",
    "antialiasedErrorBars",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush",
    "keyAxis",
    "QCPAxis*",
    "valueAxis"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPAbstractPlottableENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       3,   14, // methods
      12,   41, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   32,    2, 0x06,   13 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
       4,    1,   35,    2, 0x0a,   15 /* Public */,
       6,    1,   38,    2, 0x0a,   17 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Bool,    3,

 // slots: parameters
    QMetaType::Void, QMetaType::Bool,    5,
    QMetaType::Void, QMetaType::Bool,    3,

 // properties: name, type, flags
       7, QMetaType::QString, 0x00015103, uint(-1), 0,
       8, QMetaType::Bool, 0x00015103, uint(-1), 0,
       9, QMetaType::Bool, 0x00015103, uint(-1), 0,
      10, QMetaType::Bool, 0x00015103, uint(-1), 0,
      11, QMetaType::QPen, 0x00015103, uint(-1), 0,
      12, QMetaType::QPen, 0x00015103, uint(-1), 0,
      13, QMetaType::QBrush, 0x00015103, uint(-1), 0,
      14, QMetaType::QBrush, 0x00015103, uint(-1), 0,
      15, 0x80000000 | 16, 0x0001510b, uint(-1), 0,
      17, 0x80000000 | 16, 0x0001510b, uint(-1), 0,
       5, QMetaType::Bool, 0x00015103, uint(-1), 0,
       3, QMetaType::Bool, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPAbstractPlottable::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayerable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPAbstractPlottableENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS_t,
        // property 'name'
        QtPrivate::TypeAndForceComplete<QString, std::true_type>,
        // property 'antialiasedFill'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'antialiasedScatters'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'antialiasedErrorBars'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'brush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'selectedBrush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'keyAxis'
        QtPrivate::TypeAndForceComplete<QCPAxis*, std::true_type>,
        // property 'valueAxis'
        QtPrivate::TypeAndForceComplete<QCPAxis*, std::true_type>,
        // property 'selectable'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'selected'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPAbstractPlottable, std::true_type>,
        // method 'selectionChanged'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'setSelectable'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'setSelected'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>
    >,
    nullptr
} };

void QCPAbstractPlottable::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<QCPAbstractPlottable *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->selectionChanged((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 1: _t->setSelectable((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 2: _t->setSelected((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (QCPAbstractPlottable::*)(bool );
            if (_t _q_method = &QCPAbstractPlottable::selectionChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    } else if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 9:
        case 8:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPAxis* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPAbstractPlottable *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QString*>(_v) = _t->name(); break;
        case 1: *reinterpret_cast< bool*>(_v) = _t->antialiasedFill(); break;
        case 2: *reinterpret_cast< bool*>(_v) = _t->antialiasedScatters(); break;
        case 3: *reinterpret_cast< bool*>(_v) = _t->antialiasedErrorBars(); break;
        case 4: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 5: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        case 6: *reinterpret_cast< QBrush*>(_v) = _t->brush(); break;
        case 7: *reinterpret_cast< QBrush*>(_v) = _t->selectedBrush(); break;
        case 8: *reinterpret_cast< QCPAxis**>(_v) = _t->keyAxis(); break;
        case 9: *reinterpret_cast< QCPAxis**>(_v) = _t->valueAxis(); break;
        case 10: *reinterpret_cast< bool*>(_v) = _t->selectable(); break;
        case 11: *reinterpret_cast< bool*>(_v) = _t->selected(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPAbstractPlottable *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setName(*reinterpret_cast< QString*>(_v)); break;
        case 1: _t->setAntialiasedFill(*reinterpret_cast< bool*>(_v)); break;
        case 2: _t->setAntialiasedScatters(*reinterpret_cast< bool*>(_v)); break;
        case 3: _t->setAntialiasedErrorBars(*reinterpret_cast< bool*>(_v)); break;
        case 4: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 5: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        case 6: _t->setBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 7: _t->setSelectedBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 8: _t->setKeyAxis(*reinterpret_cast< QCPAxis**>(_v)); break;
        case 9: _t->setValueAxis(*reinterpret_cast< QCPAxis**>(_v)); break;
        case 10: _t->setSelectable(*reinterpret_cast< bool*>(_v)); break;
        case 11: _t->setSelected(*reinterpret_cast< bool*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
}

const QMetaObject *QCPAbstractPlottable::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPAbstractPlottable::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPAbstractPlottableENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayerable::qt_metacast(_clname);
}

int QCPAbstractPlottable::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayerable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 3)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 3)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 3;
    }else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 12;
    }
    return _id;
}

// SIGNAL 0
void QCPAbstractPlottable::selectionChanged(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS = QtMocHelpers::stringData(
    "QCPAbstractItem",
    "selectionChanged",
    "",
    "selected",
    "clipToAxisRect",
    "clipAxisRect",
    "QCPAxisRect*",
    "selectable"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS_t {
    uint offsetsAndSizes[16];
    char stringdata0[16];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[9];
    char stringdata4[15];
    char stringdata5[13];
    char stringdata6[13];
    char stringdata7[11];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS_t qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS = {
    {
        QT_MOC_LITERAL(0, 15),  // "QCPAbstractItem"
        QT_MOC_LITERAL(16, 16),  // "selectionChanged"
        QT_MOC_LITERAL(33, 0),  // ""
        QT_MOC_LITERAL(34, 8),  // "selected"
        QT_MOC_LITERAL(43, 14),  // "clipToAxisRect"
        QT_MOC_LITERAL(58, 12),  // "clipAxisRect"
        QT_MOC_LITERAL(71, 12),  // "QCPAxisRect*"
        QT_MOC_LITERAL(84, 10)   // "selectable"
    },
    "QCPAbstractItem",
    "selectionChanged",
    "",
    "selected",
    "clipToAxisRect",
    "clipAxisRect",
    "QCPAxisRect*",
    "selectable"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPAbstractItemENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       4,   23, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x06,    5 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Bool,    3,

 // properties: name, type, flags
       4, QMetaType::Bool, 0x00015103, uint(-1), 0,
       5, 0x80000000 | 6, 0x0001510b, uint(-1), 0,
       7, QMetaType::Bool, 0x00015103, uint(-1), 0,
       3, QMetaType::Bool, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPAbstractItem::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayerable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPAbstractItemENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS_t,
        // property 'clipToAxisRect'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'clipAxisRect'
        QtPrivate::TypeAndForceComplete<QCPAxisRect*, std::true_type>,
        // property 'selectable'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'selected'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPAbstractItem, std::true_type>,
        // method 'selectionChanged'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>
    >,
    nullptr
} };

void QCPAbstractItem::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<QCPAbstractItem *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->selectionChanged((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (QCPAbstractItem::*)(bool );
            if (_t _q_method = &QCPAbstractItem::selectionChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    } else if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 1:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPAxisRect* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPAbstractItem *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< bool*>(_v) = _t->clipToAxisRect(); break;
        case 1: *reinterpret_cast< QCPAxisRect**>(_v) = _t->clipAxisRect(); break;
        case 2: *reinterpret_cast< bool*>(_v) = _t->selectable(); break;
        case 3: *reinterpret_cast< bool*>(_v) = _t->selected(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPAbstractItem *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setClipToAxisRect(*reinterpret_cast< bool*>(_v)); break;
        case 1: _t->setClipAxisRect(*reinterpret_cast< QCPAxisRect**>(_v)); break;
        case 2: _t->setSelectable(*reinterpret_cast< bool*>(_v)); break;
        case 3: _t->setSelected(*reinterpret_cast< bool*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
}

const QMetaObject *QCPAbstractItem::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPAbstractItem::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPAbstractItemENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayerable::qt_metacast(_clname);
}

int QCPAbstractItem::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayerable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    }
    return _id;
}

// SIGNAL 0
void QCPAbstractItem::selectionChanged(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCustomPlotENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCustomPlotENDCLASS = QtMocHelpers::stringData(
    "QCustomPlot",
    "mouseDoubleClick",
    "",
    "QMouseEvent*",
    "event",
    "mousePress",
    "mouseMove",
    "mouseRelease",
    "mouseWheel",
    "QWheelEvent*",
    "plottableClick",
    "QCPAbstractPlottable*",
    "plottable",
    "plottableDoubleClick",
    "itemClick",
    "QCPAbstractItem*",
    "item",
    "itemDoubleClick",
    "axisClick",
    "QCPAxis*",
    "axis",
    "QCPAxis::SelectablePart",
    "part",
    "axisDoubleClick",
    "legendClick",
    "QCPLegend*",
    "legend",
    "QCPAbstractLegendItem*",
    "legendDoubleClick",
    "titleClick",
    "QCPPlotTitle*",
    "title",
    "titleDoubleClick",
    "selectionChangedByUser",
    "beforeReplot",
    "afterReplot",
    "rescaleAxes",
    "onlyVisiblePlottables",
    "deselectAll",
    "replot",
    "viewport",
    "background",
    "backgroundScaled",
    "backgroundScaledMode",
    "Qt::AspectRatioMode",
    "plotLayout",
    "QCPLayoutGrid*",
    "autoAddPlottableToLegend",
    "selectionTolerance",
    "noAntialiasingOnDrag",
    "multiSelectModifier",
    "Qt::KeyboardModifier",
    "LayerInsertMode",
    "limBelow",
    "limAbove"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCustomPlotENDCLASS_t {
    uint offsetsAndSizes[110];
    char stringdata0[12];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[13];
    char stringdata4[6];
    char stringdata5[11];
    char stringdata6[10];
    char stringdata7[13];
    char stringdata8[11];
    char stringdata9[13];
    char stringdata10[15];
    char stringdata11[22];
    char stringdata12[10];
    char stringdata13[21];
    char stringdata14[10];
    char stringdata15[17];
    char stringdata16[5];
    char stringdata17[16];
    char stringdata18[10];
    char stringdata19[9];
    char stringdata20[5];
    char stringdata21[24];
    char stringdata22[5];
    char stringdata23[16];
    char stringdata24[12];
    char stringdata25[11];
    char stringdata26[7];
    char stringdata27[23];
    char stringdata28[18];
    char stringdata29[11];
    char stringdata30[14];
    char stringdata31[6];
    char stringdata32[17];
    char stringdata33[23];
    char stringdata34[13];
    char stringdata35[12];
    char stringdata36[12];
    char stringdata37[22];
    char stringdata38[12];
    char stringdata39[7];
    char stringdata40[9];
    char stringdata41[11];
    char stringdata42[17];
    char stringdata43[21];
    char stringdata44[20];
    char stringdata45[11];
    char stringdata46[15];
    char stringdata47[25];
    char stringdata48[19];
    char stringdata49[21];
    char stringdata50[20];
    char stringdata51[21];
    char stringdata52[16];
    char stringdata53[9];
    char stringdata54[9];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCustomPlotENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCustomPlotENDCLASS_t qt_meta_stringdata_CLASSQCustomPlotENDCLASS = {
    {
        QT_MOC_LITERAL(0, 11),  // "QCustomPlot"
        QT_MOC_LITERAL(12, 16),  // "mouseDoubleClick"
        QT_MOC_LITERAL(29, 0),  // ""
        QT_MOC_LITERAL(30, 12),  // "QMouseEvent*"
        QT_MOC_LITERAL(43, 5),  // "event"
        QT_MOC_LITERAL(49, 10),  // "mousePress"
        QT_MOC_LITERAL(60, 9),  // "mouseMove"
        QT_MOC_LITERAL(70, 12),  // "mouseRelease"
        QT_MOC_LITERAL(83, 10),  // "mouseWheel"
        QT_MOC_LITERAL(94, 12),  // "QWheelEvent*"
        QT_MOC_LITERAL(107, 14),  // "plottableClick"
        QT_MOC_LITERAL(122, 21),  // "QCPAbstractPlottable*"
        QT_MOC_LITERAL(144, 9),  // "plottable"
        QT_MOC_LITERAL(154, 20),  // "plottableDoubleClick"
        QT_MOC_LITERAL(175, 9),  // "itemClick"
        QT_MOC_LITERAL(185, 16),  // "QCPAbstractItem*"
        QT_MOC_LITERAL(202, 4),  // "item"
        QT_MOC_LITERAL(207, 15),  // "itemDoubleClick"
        QT_MOC_LITERAL(223, 9),  // "axisClick"
        QT_MOC_LITERAL(233, 8),  // "QCPAxis*"
        QT_MOC_LITERAL(242, 4),  // "axis"
        QT_MOC_LITERAL(247, 23),  // "QCPAxis::SelectablePart"
        QT_MOC_LITERAL(271, 4),  // "part"
        QT_MOC_LITERAL(276, 15),  // "axisDoubleClick"
        QT_MOC_LITERAL(292, 11),  // "legendClick"
        QT_MOC_LITERAL(304, 10),  // "QCPLegend*"
        QT_MOC_LITERAL(315, 6),  // "legend"
        QT_MOC_LITERAL(322, 22),  // "QCPAbstractLegendItem*"
        QT_MOC_LITERAL(345, 17),  // "legendDoubleClick"
        QT_MOC_LITERAL(363, 10),  // "titleClick"
        QT_MOC_LITERAL(374, 13),  // "QCPPlotTitle*"
        QT_MOC_LITERAL(388, 5),  // "title"
        QT_MOC_LITERAL(394, 16),  // "titleDoubleClick"
        QT_MOC_LITERAL(411, 22),  // "selectionChangedByUser"
        QT_MOC_LITERAL(434, 12),  // "beforeReplot"
        QT_MOC_LITERAL(447, 11),  // "afterReplot"
        QT_MOC_LITERAL(459, 11),  // "rescaleAxes"
        QT_MOC_LITERAL(471, 21),  // "onlyVisiblePlottables"
        QT_MOC_LITERAL(493, 11),  // "deselectAll"
        QT_MOC_LITERAL(505, 6),  // "replot"
        QT_MOC_LITERAL(512, 8),  // "viewport"
        QT_MOC_LITERAL(521, 10),  // "background"
        QT_MOC_LITERAL(532, 16),  // "backgroundScaled"
        QT_MOC_LITERAL(549, 20),  // "backgroundScaledMode"
        QT_MOC_LITERAL(570, 19),  // "Qt::AspectRatioMode"
        QT_MOC_LITERAL(590, 10),  // "plotLayout"
        QT_MOC_LITERAL(601, 14),  // "QCPLayoutGrid*"
        QT_MOC_LITERAL(616, 24),  // "autoAddPlottableToLegend"
        QT_MOC_LITERAL(641, 18),  // "selectionTolerance"
        QT_MOC_LITERAL(660, 20),  // "noAntialiasingOnDrag"
        QT_MOC_LITERAL(681, 19),  // "multiSelectModifier"
        QT_MOC_LITERAL(701, 20),  // "Qt::KeyboardModifier"
        QT_MOC_LITERAL(722, 15),  // "LayerInsertMode"
        QT_MOC_LITERAL(738, 8),  // "limBelow"
        QT_MOC_LITERAL(747, 8)   // "limAbove"
    },
    "QCustomPlot",
    "mouseDoubleClick",
    "",
    "QMouseEvent*",
    "event",
    "mousePress",
    "mouseMove",
    "mouseRelease",
    "mouseWheel",
    "QWheelEvent*",
    "plottableClick",
    "QCPAbstractPlottable*",
    "plottable",
    "plottableDoubleClick",
    "itemClick",
    "QCPAbstractItem*",
    "item",
    "itemDoubleClick",
    "axisClick",
    "QCPAxis*",
    "axis",
    "QCPAxis::SelectablePart",
    "part",
    "axisDoubleClick",
    "legendClick",
    "QCPLegend*",
    "legend",
    "QCPAbstractLegendItem*",
    "legendDoubleClick",
    "titleClick",
    "QCPPlotTitle*",
    "title",
    "titleDoubleClick",
    "selectionChangedByUser",
    "beforeReplot",
    "afterReplot",
    "rescaleAxes",
    "onlyVisiblePlottables",
    "deselectAll",
    "replot",
    "viewport",
    "background",
    "backgroundScaled",
    "backgroundScaledMode",
    "Qt::AspectRatioMode",
    "plotLayout",
    "QCPLayoutGrid*",
    "autoAddPlottableToLegend",
    "selectionTolerance",
    "noAntialiasingOnDrag",
    "multiSelectModifier",
    "Qt::KeyboardModifier",
    "LayerInsertMode",
    "limBelow",
    "limAbove"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCustomPlotENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
      22,   14, // methods
       9,  228, // properties
       1,  273, // enums/sets
       0,    0, // constructors
       0,       // flags
      18,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,  146,    2, 0x06,   10 /* Public */,
       5,    1,  149,    2, 0x06,   12 /* Public */,
       6,    1,  152,    2, 0x06,   14 /* Public */,
       7,    1,  155,    2, 0x06,   16 /* Public */,
       8,    1,  158,    2, 0x06,   18 /* Public */,
      10,    2,  161,    2, 0x06,   20 /* Public */,
      13,    2,  166,    2, 0x06,   23 /* Public */,
      14,    2,  171,    2, 0x06,   26 /* Public */,
      17,    2,  176,    2, 0x06,   29 /* Public */,
      18,    3,  181,    2, 0x06,   32 /* Public */,
      23,    3,  188,    2, 0x06,   36 /* Public */,
      24,    3,  195,    2, 0x06,   40 /* Public */,
      28,    3,  202,    2, 0x06,   44 /* Public */,
      29,    2,  209,    2, 0x06,   48 /* Public */,
      32,    2,  214,    2, 0x06,   51 /* Public */,
      33,    0,  219,    2, 0x06,   54 /* Public */,
      34,    0,  220,    2, 0x06,   55 /* Public */,
      35,    0,  221,    2, 0x06,   56 /* Public */,

 // slots: name, argc, parameters, tag, flags, initial metatype offsets
      36,    1,  222,    2, 0x0a,   57 /* Public */,
      36,    0,  225,    2, 0x2a,   59 /* Public | MethodCloned */,
      38,    0,  226,    2, 0x0a,   60 /* Public */,
      39,    0,  227,    2, 0x0a,   61 /* Public */,

 // signals: parameters
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, 0x80000000 | 3,    4,
    QMetaType::Void, 0x80000000 | 9,    4,
    QMetaType::Void, 0x80000000 | 11, 0x80000000 | 3,   12,    4,
    QMetaType::Void, 0x80000000 | 11, 0x80000000 | 3,   12,    4,
    QMetaType::Void, 0x80000000 | 15, 0x80000000 | 3,   16,    4,
    QMetaType::Void, 0x80000000 | 15, 0x80000000 | 3,   16,    4,
    QMetaType::Void, 0x80000000 | 19, 0x80000000 | 21, 0x80000000 | 3,   20,   22,    4,
    QMetaType::Void, 0x80000000 | 19, 0x80000000 | 21, 0x80000000 | 3,   20,   22,    4,
    QMetaType::Void, 0x80000000 | 25, 0x80000000 | 27, 0x80000000 | 3,   26,   16,    4,
    QMetaType::Void, 0x80000000 | 25, 0x80000000 | 27, 0x80000000 | 3,   26,   16,    4,
    QMetaType::Void, 0x80000000 | 3, 0x80000000 | 30,    4,   31,
    QMetaType::Void, 0x80000000 | 3, 0x80000000 | 30,    4,   31,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void, QMetaType::Bool,   37,
    QMetaType::Void,
    QMetaType::Void,
    QMetaType::Void,

 // properties: name, type, flags
      40, QMetaType::QRect, 0x00015103, uint(-1), 0,
      41, QMetaType::QPixmap, 0x00015103, uint(-1), 0,
      42, QMetaType::Bool, 0x00015103, uint(-1), 0,
      43, 0x80000000 | 44, 0x0001510b, uint(-1), 0,
      45, 0x80000000 | 46, 0x00015009, uint(-1), 0,
      47, QMetaType::Bool, 0x00015103, uint(-1), 0,
      48, QMetaType::Int, 0x00015103, uint(-1), 0,
      49, QMetaType::Bool, 0x00015103, uint(-1), 0,
      50, 0x80000000 | 51, 0x0001510b, uint(-1), 0,

 // enums: name, alias, flags, count, data
      52,   52, 0x0,    2,  278,

 // enum data: key, value
      53, uint(QCustomPlot::limBelow),
      54, uint(QCustomPlot::limAbove),

       0        // eod
};

Q_CONSTINIT const QMetaObject QCustomPlot::staticMetaObject = { {
    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCustomPlotENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCustomPlotENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCustomPlotENDCLASS_t,
        // property 'viewport'
        QtPrivate::TypeAndForceComplete<QRect, std::true_type>,
        // property 'background'
        QtPrivate::TypeAndForceComplete<QPixmap, std::true_type>,
        // property 'backgroundScaled'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'backgroundScaledMode'
        QtPrivate::TypeAndForceComplete<Qt::AspectRatioMode, std::true_type>,
        // property 'plotLayout'
        QtPrivate::TypeAndForceComplete<QCPLayoutGrid*, std::true_type>,
        // property 'autoAddPlottableToLegend'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'selectionTolerance'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'noAntialiasingOnDrag'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'multiSelectModifier'
        QtPrivate::TypeAndForceComplete<Qt::KeyboardModifier, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCustomPlot, std::true_type>,
        // method 'mouseDoubleClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'mousePress'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'mouseMove'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'mouseRelease'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'mouseWheel'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QWheelEvent *, std::false_type>,
        // method 'plottableClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAbstractPlottable *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'plottableDoubleClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAbstractPlottable *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'itemClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAbstractItem *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'itemDoubleClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAbstractItem *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'axisClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAxis *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAxis::SelectablePart, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'axisDoubleClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAxis *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAxis::SelectablePart, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'legendClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPLegend *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAbstractLegendItem *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'legendDoubleClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPLegend *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPAbstractLegendItem *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        // method 'titleClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPPlotTitle *, std::false_type>,
        // method 'titleDoubleClick'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QMouseEvent *, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPPlotTitle *, std::false_type>,
        // method 'selectionChangedByUser'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'beforeReplot'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'afterReplot'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'rescaleAxes'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>,
        // method 'rescaleAxes'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'deselectAll'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        // method 'replot'
        QtPrivate::TypeAndForceComplete<void, std::false_type>
    >,
    nullptr
} };

void QCustomPlot::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<QCustomPlot *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->mouseDoubleClick((*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[1]))); break;
        case 1: _t->mousePress((*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[1]))); break;
        case 2: _t->mouseMove((*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[1]))); break;
        case 3: _t->mouseRelease((*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[1]))); break;
        case 4: _t->mouseWheel((*reinterpret_cast< std::add_pointer_t<QWheelEvent*>>(_a[1]))); break;
        case 5: _t->plottableClick((*reinterpret_cast< std::add_pointer_t<QCPAbstractPlottable*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[2]))); break;
        case 6: _t->plottableDoubleClick((*reinterpret_cast< std::add_pointer_t<QCPAbstractPlottable*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[2]))); break;
        case 7: _t->itemClick((*reinterpret_cast< std::add_pointer_t<QCPAbstractItem*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[2]))); break;
        case 8: _t->itemDoubleClick((*reinterpret_cast< std::add_pointer_t<QCPAbstractItem*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[2]))); break;
        case 9: _t->axisClick((*reinterpret_cast< std::add_pointer_t<QCPAxis*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QCPAxis::SelectablePart>>(_a[2])),(*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[3]))); break;
        case 10: _t->axisDoubleClick((*reinterpret_cast< std::add_pointer_t<QCPAxis*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QCPAxis::SelectablePart>>(_a[2])),(*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[3]))); break;
        case 11: _t->legendClick((*reinterpret_cast< std::add_pointer_t<QCPLegend*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QCPAbstractLegendItem*>>(_a[2])),(*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[3]))); break;
        case 12: _t->legendDoubleClick((*reinterpret_cast< std::add_pointer_t<QCPLegend*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QCPAbstractLegendItem*>>(_a[2])),(*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[3]))); break;
        case 13: _t->titleClick((*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QCPPlotTitle*>>(_a[2]))); break;
        case 14: _t->titleDoubleClick((*reinterpret_cast< std::add_pointer_t<QMouseEvent*>>(_a[1])),(*reinterpret_cast< std::add_pointer_t<QCPPlotTitle*>>(_a[2]))); break;
        case 15: _t->selectionChangedByUser(); break;
        case 16: _t->beforeReplot(); break;
        case 17: _t->afterReplot(); break;
        case 18: _t->rescaleAxes((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        case 19: _t->rescaleAxes(); break;
        case 20: _t->deselectAll(); break;
        case 21: _t->replot(); break;
        default: ;
        }
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        switch (_id) {
        default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
        case 5:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 0:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAbstractPlottable* >(); break;
            }
            break;
        case 6:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 0:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAbstractPlottable* >(); break;
            }
            break;
        case 7:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 0:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAbstractItem* >(); break;
            }
            break;
        case 8:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 0:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAbstractItem* >(); break;
            }
            break;
        case 9:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 0:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAxis* >(); break;
            case 1:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAxis::SelectablePart >(); break;
            }
            break;
        case 10:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 0:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAxis* >(); break;
            case 1:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAxis::SelectablePart >(); break;
            }
            break;
        case 11:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 1:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAbstractLegendItem* >(); break;
            case 0:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPLegend* >(); break;
            }
            break;
        case 12:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 1:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPAbstractLegendItem* >(); break;
            case 0:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPLegend* >(); break;
            }
            break;
        case 13:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 1:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPPlotTitle* >(); break;
            }
            break;
        case 14:
            switch (*reinterpret_cast<int*>(_a[1])) {
            default: *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType(); break;
            case 1:
                *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType::fromType< QCPPlotTitle* >(); break;
            }
            break;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (QCustomPlot::*)(QMouseEvent * );
            if (_t _q_method = &QCustomPlot::mouseDoubleClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QMouseEvent * );
            if (_t _q_method = &QCustomPlot::mousePress; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 1;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QMouseEvent * );
            if (_t _q_method = &QCustomPlot::mouseMove; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 2;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QMouseEvent * );
            if (_t _q_method = &QCustomPlot::mouseRelease; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 3;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QWheelEvent * );
            if (_t _q_method = &QCustomPlot::mouseWheel; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 4;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QCPAbstractPlottable * , QMouseEvent * );
            if (_t _q_method = &QCustomPlot::plottableClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 5;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QCPAbstractPlottable * , QMouseEvent * );
            if (_t _q_method = &QCustomPlot::plottableDoubleClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 6;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QCPAbstractItem * , QMouseEvent * );
            if (_t _q_method = &QCustomPlot::itemClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 7;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QCPAbstractItem * , QMouseEvent * );
            if (_t _q_method = &QCustomPlot::itemDoubleClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 8;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QCPAxis * , QCPAxis::SelectablePart , QMouseEvent * );
            if (_t _q_method = &QCustomPlot::axisClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 9;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QCPAxis * , QCPAxis::SelectablePart , QMouseEvent * );
            if (_t _q_method = &QCustomPlot::axisDoubleClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 10;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QCPLegend * , QCPAbstractLegendItem * , QMouseEvent * );
            if (_t _q_method = &QCustomPlot::legendClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 11;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QCPLegend * , QCPAbstractLegendItem * , QMouseEvent * );
            if (_t _q_method = &QCustomPlot::legendDoubleClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 12;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QMouseEvent * , QCPPlotTitle * );
            if (_t _q_method = &QCustomPlot::titleClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 13;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)(QMouseEvent * , QCPPlotTitle * );
            if (_t _q_method = &QCustomPlot::titleDoubleClick; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 14;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)();
            if (_t _q_method = &QCustomPlot::selectionChangedByUser; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 15;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)();
            if (_t _q_method = &QCustomPlot::beforeReplot; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 16;
                return;
            }
        }
        {
            using _t = void (QCustomPlot::*)();
            if (_t _q_method = &QCustomPlot::afterReplot; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 17;
                return;
            }
        }
    } else if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 4:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPLayoutGrid* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCustomPlot *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QRect*>(_v) = _t->viewport(); break;
        case 1: *reinterpret_cast< QPixmap*>(_v) = _t->background(); break;
        case 2: *reinterpret_cast< bool*>(_v) = _t->backgroundScaled(); break;
        case 3: *reinterpret_cast< Qt::AspectRatioMode*>(_v) = _t->backgroundScaledMode(); break;
        case 4: *reinterpret_cast< QCPLayoutGrid**>(_v) = _t->plotLayout(); break;
        case 5: *reinterpret_cast< bool*>(_v) = _t->autoAddPlottableToLegend(); break;
        case 6: *reinterpret_cast< int*>(_v) = _t->selectionTolerance(); break;
        case 7: *reinterpret_cast< bool*>(_v) = _t->noAntialiasingOnDrag(); break;
        case 8: *reinterpret_cast< Qt::KeyboardModifier*>(_v) = _t->multiSelectModifier(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCustomPlot *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setViewport(*reinterpret_cast< QRect*>(_v)); break;
        case 1: _t->setBackground(*reinterpret_cast< QPixmap*>(_v)); break;
        case 2: _t->setBackgroundScaled(*reinterpret_cast< bool*>(_v)); break;
        case 3: _t->setBackgroundScaledMode(*reinterpret_cast< Qt::AspectRatioMode*>(_v)); break;
        case 5: _t->setAutoAddPlottableToLegend(*reinterpret_cast< bool*>(_v)); break;
        case 6: _t->setSelectionTolerance(*reinterpret_cast< int*>(_v)); break;
        case 7: _t->setNoAntialiasingOnDrag(*reinterpret_cast< bool*>(_v)); break;
        case 8: _t->setMultiSelectModifier(*reinterpret_cast< Qt::KeyboardModifier*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
}

const QMetaObject *QCustomPlot::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCustomPlot::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCustomPlotENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QWidget::qt_metacast(_clname);
}

int QCustomPlot::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QWidget::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 22)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 22;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 22)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 22;
    }else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 9;
    }
    return _id;
}

// SIGNAL 0
void QCustomPlot::mouseDoubleClick(QMouseEvent * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void QCustomPlot::mousePress(QMouseEvent * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 1, _a);
}

// SIGNAL 2
void QCustomPlot::mouseMove(QMouseEvent * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 2, _a);
}

// SIGNAL 3
void QCustomPlot::mouseRelease(QMouseEvent * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 3, _a);
}

// SIGNAL 4
void QCustomPlot::mouseWheel(QWheelEvent * _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 4, _a);
}

// SIGNAL 5
void QCustomPlot::plottableClick(QCPAbstractPlottable * _t1, QMouseEvent * _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 5, _a);
}

// SIGNAL 6
void QCustomPlot::plottableDoubleClick(QCPAbstractPlottable * _t1, QMouseEvent * _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 6, _a);
}

// SIGNAL 7
void QCustomPlot::itemClick(QCPAbstractItem * _t1, QMouseEvent * _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 7, _a);
}

// SIGNAL 8
void QCustomPlot::itemDoubleClick(QCPAbstractItem * _t1, QMouseEvent * _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 8, _a);
}

// SIGNAL 9
void QCustomPlot::axisClick(QCPAxis * _t1, QCPAxis::SelectablePart _t2, QMouseEvent * _t3)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t3))) };
    QMetaObject::activate(this, &staticMetaObject, 9, _a);
}

// SIGNAL 10
void QCustomPlot::axisDoubleClick(QCPAxis * _t1, QCPAxis::SelectablePart _t2, QMouseEvent * _t3)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t3))) };
    QMetaObject::activate(this, &staticMetaObject, 10, _a);
}

// SIGNAL 11
void QCustomPlot::legendClick(QCPLegend * _t1, QCPAbstractLegendItem * _t2, QMouseEvent * _t3)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t3))) };
    QMetaObject::activate(this, &staticMetaObject, 11, _a);
}

// SIGNAL 12
void QCustomPlot::legendDoubleClick(QCPLegend * _t1, QCPAbstractLegendItem * _t2, QMouseEvent * _t3)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t3))) };
    QMetaObject::activate(this, &staticMetaObject, 12, _a);
}

// SIGNAL 13
void QCustomPlot::titleClick(QMouseEvent * _t1, QCPPlotTitle * _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 13, _a);
}

// SIGNAL 14
void QCustomPlot::titleDoubleClick(QMouseEvent * _t1, QCPPlotTitle * _t2)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))), const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t2))) };
    QMetaObject::activate(this, &staticMetaObject, 14, _a);
}

// SIGNAL 15
void QCustomPlot::selectionChangedByUser()
{
    QMetaObject::activate(this, &staticMetaObject, 15, nullptr);
}

// SIGNAL 16
void QCustomPlot::beforeReplot()
{
    QMetaObject::activate(this, &staticMetaObject, 16, nullptr);
}

// SIGNAL 17
void QCustomPlot::afterReplot()
{
    QMetaObject::activate(this, &staticMetaObject, 17, nullptr);
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPGraphENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPGraphENDCLASS = QtMocHelpers::stringData(
    "QCPGraph",
    "lineStyle",
    "LineStyle",
    "scatterStyle",
    "QCPScatterStyle",
    "errorType",
    "ErrorType",
    "errorPen",
    "errorBarSize",
    "errorBarSkipSymbol",
    "channelFillGraph",
    "QCPGraph*",
    "lsNone",
    "lsLine",
    "lsStepLeft",
    "lsStepRight",
    "lsStepCenter",
    "lsImpulse",
    "etNone",
    "etKey",
    "etValue",
    "etBoth"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPGraphENDCLASS_t {
    uint offsetsAndSizes[44];
    char stringdata0[9];
    char stringdata1[10];
    char stringdata2[10];
    char stringdata3[13];
    char stringdata4[16];
    char stringdata5[10];
    char stringdata6[10];
    char stringdata7[9];
    char stringdata8[13];
    char stringdata9[19];
    char stringdata10[17];
    char stringdata11[10];
    char stringdata12[7];
    char stringdata13[7];
    char stringdata14[11];
    char stringdata15[12];
    char stringdata16[13];
    char stringdata17[10];
    char stringdata18[7];
    char stringdata19[6];
    char stringdata20[8];
    char stringdata21[7];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPGraphENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPGraphENDCLASS_t qt_meta_stringdata_CLASSQCPGraphENDCLASS = {
    {
        QT_MOC_LITERAL(0, 8),  // "QCPGraph"
        QT_MOC_LITERAL(9, 9),  // "lineStyle"
        QT_MOC_LITERAL(19, 9),  // "LineStyle"
        QT_MOC_LITERAL(29, 12),  // "scatterStyle"
        QT_MOC_LITERAL(42, 15),  // "QCPScatterStyle"
        QT_MOC_LITERAL(58, 9),  // "errorType"
        QT_MOC_LITERAL(68, 9),  // "ErrorType"
        QT_MOC_LITERAL(78, 8),  // "errorPen"
        QT_MOC_LITERAL(87, 12),  // "errorBarSize"
        QT_MOC_LITERAL(100, 18),  // "errorBarSkipSymbol"
        QT_MOC_LITERAL(119, 16),  // "channelFillGraph"
        QT_MOC_LITERAL(136, 9),  // "QCPGraph*"
        QT_MOC_LITERAL(146, 6),  // "lsNone"
        QT_MOC_LITERAL(153, 6),  // "lsLine"
        QT_MOC_LITERAL(160, 10),  // "lsStepLeft"
        QT_MOC_LITERAL(171, 11),  // "lsStepRight"
        QT_MOC_LITERAL(183, 12),  // "lsStepCenter"
        QT_MOC_LITERAL(196, 9),  // "lsImpulse"
        QT_MOC_LITERAL(206, 6),  // "etNone"
        QT_MOC_LITERAL(213, 5),  // "etKey"
        QT_MOC_LITERAL(219, 7),  // "etValue"
        QT_MOC_LITERAL(227, 6)   // "etBoth"
    },
    "QCPGraph",
    "lineStyle",
    "LineStyle",
    "scatterStyle",
    "QCPScatterStyle",
    "errorType",
    "ErrorType",
    "errorPen",
    "errorBarSize",
    "errorBarSkipSymbol",
    "channelFillGraph",
    "QCPGraph*",
    "lsNone",
    "lsLine",
    "lsStepLeft",
    "lsStepRight",
    "lsStepCenter",
    "lsImpulse",
    "etNone",
    "etKey",
    "etValue",
    "etBoth"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPGraphENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       7,   14, // properties
       2,   49, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, 0x80000000 | 2, 0x0001510b, uint(-1), 0,
       3, 0x80000000 | 4, 0x0001510b, uint(-1), 0,
       5, 0x80000000 | 6, 0x0001510b, uint(-1), 0,
       7, QMetaType::QPen, 0x00015103, uint(-1), 0,
       8, QMetaType::Double, 0x00015103, uint(-1), 0,
       9, QMetaType::Bool, 0x00015103, uint(-1), 0,
      10, 0x80000000 | 11, 0x0001510b, uint(-1), 0,

 // enums: name, alias, flags, count, data
       2,    2, 0x0,    6,   59,
       6,    6, 0x0,    4,   71,

 // enum data: key, value
      12, uint(QCPGraph::lsNone),
      13, uint(QCPGraph::lsLine),
      14, uint(QCPGraph::lsStepLeft),
      15, uint(QCPGraph::lsStepRight),
      16, uint(QCPGraph::lsStepCenter),
      17, uint(QCPGraph::lsImpulse),
      18, uint(QCPGraph::etNone),
      19, uint(QCPGraph::etKey),
      20, uint(QCPGraph::etValue),
      21, uint(QCPGraph::etBoth),

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPGraph::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractPlottable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPGraphENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPGraphENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPGraphENDCLASS_t,
        // property 'lineStyle'
        QtPrivate::TypeAndForceComplete<LineStyle, std::true_type>,
        // property 'scatterStyle'
        QtPrivate::TypeAndForceComplete<QCPScatterStyle, std::true_type>,
        // property 'errorType'
        QtPrivate::TypeAndForceComplete<ErrorType, std::true_type>,
        // property 'errorPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'errorBarSize'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'errorBarSkipSymbol'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'channelFillGraph'
        QtPrivate::TypeAndForceComplete<QCPGraph*, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPGraph, std::true_type>
    >,
    nullptr
} };

void QCPGraph::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 6:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPGraph* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPGraph *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< LineStyle*>(_v) = _t->lineStyle(); break;
        case 1: *reinterpret_cast< QCPScatterStyle*>(_v) = _t->scatterStyle(); break;
        case 2: *reinterpret_cast< ErrorType*>(_v) = _t->errorType(); break;
        case 3: *reinterpret_cast< QPen*>(_v) = _t->errorPen(); break;
        case 4: *reinterpret_cast< double*>(_v) = _t->errorBarSize(); break;
        case 5: *reinterpret_cast< bool*>(_v) = _t->errorBarSkipSymbol(); break;
        case 6: *reinterpret_cast< QCPGraph**>(_v) = _t->channelFillGraph(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPGraph *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setLineStyle(*reinterpret_cast< LineStyle*>(_v)); break;
        case 1: _t->setScatterStyle(*reinterpret_cast< QCPScatterStyle*>(_v)); break;
        case 2: _t->setErrorType(*reinterpret_cast< ErrorType*>(_v)); break;
        case 3: _t->setErrorPen(*reinterpret_cast< QPen*>(_v)); break;
        case 4: _t->setErrorBarSize(*reinterpret_cast< double*>(_v)); break;
        case 5: _t->setErrorBarSkipSymbol(*reinterpret_cast< bool*>(_v)); break;
        case 6: _t->setChannelFillGraph(*reinterpret_cast< QCPGraph**>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
}

const QMetaObject *QCPGraph::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPGraph::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPGraphENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractPlottable::qt_metacast(_clname);
}

int QCPGraph::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractPlottable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 7;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPCurveENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPCurveENDCLASS = QtMocHelpers::stringData(
    "QCPCurve",
    "scatterStyle",
    "QCPScatterStyle",
    "lineStyle",
    "LineStyle"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPCurveENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[9];
    char stringdata1[13];
    char stringdata2[16];
    char stringdata3[10];
    char stringdata4[10];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPCurveENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPCurveENDCLASS_t qt_meta_stringdata_CLASSQCPCurveENDCLASS = {
    {
        QT_MOC_LITERAL(0, 8),  // "QCPCurve"
        QT_MOC_LITERAL(9, 12),  // "scatterStyle"
        QT_MOC_LITERAL(22, 15),  // "QCPScatterStyle"
        QT_MOC_LITERAL(38, 9),  // "lineStyle"
        QT_MOC_LITERAL(48, 9)   // "LineStyle"
    },
    "QCPCurve",
    "scatterStyle",
    "QCPScatterStyle",
    "lineStyle",
    "LineStyle"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPCurveENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       2,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, 0x80000000 | 2, 0x0001510b, uint(-1), 0,
       3, 0x80000000 | 4, 0x0001510b, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPCurve::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractPlottable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPCurveENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPCurveENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPCurveENDCLASS_t,
        // property 'scatterStyle'
        QtPrivate::TypeAndForceComplete<QCPScatterStyle, std::true_type>,
        // property 'lineStyle'
        QtPrivate::TypeAndForceComplete<LineStyle, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPCurve, std::true_type>
    >,
    nullptr
} };

void QCPCurve::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPCurve *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QCPScatterStyle*>(_v) = _t->scatterStyle(); break;
        case 1: *reinterpret_cast< LineStyle*>(_v) = _t->lineStyle(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPCurve *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setScatterStyle(*reinterpret_cast< QCPScatterStyle*>(_v)); break;
        case 1: _t->setLineStyle(*reinterpret_cast< LineStyle*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPCurve::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPCurve::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPCurveENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractPlottable::qt_metacast(_clname);
}

int QCPCurve::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractPlottable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPBarsENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPBarsENDCLASS = QtMocHelpers::stringData(
    "QCPBars",
    "width",
    "barBelow",
    "QCPBars*",
    "barAbove"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPBarsENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[8];
    char stringdata1[6];
    char stringdata2[9];
    char stringdata3[9];
    char stringdata4[9];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPBarsENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPBarsENDCLASS_t qt_meta_stringdata_CLASSQCPBarsENDCLASS = {
    {
        QT_MOC_LITERAL(0, 7),  // "QCPBars"
        QT_MOC_LITERAL(8, 5),  // "width"
        QT_MOC_LITERAL(14, 8),  // "barBelow"
        QT_MOC_LITERAL(23, 8),  // "QCPBars*"
        QT_MOC_LITERAL(32, 8)   // "barAbove"
    },
    "QCPBars",
    "width",
    "barBelow",
    "QCPBars*",
    "barAbove"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPBarsENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       3,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::Double, 0x00015103, uint(-1), 0,
       2, 0x80000000 | 3, 0x00015009, uint(-1), 0,
       4, 0x80000000 | 3, 0x00015009, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPBars::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractPlottable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPBarsENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPBarsENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPBarsENDCLASS_t,
        // property 'width'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'barBelow'
        QtPrivate::TypeAndForceComplete<QCPBars*, std::true_type>,
        // property 'barAbove'
        QtPrivate::TypeAndForceComplete<QCPBars*, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPBars, std::true_type>
    >,
    nullptr
} };

void QCPBars::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 2:
        case 1:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPBars* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPBars *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< double*>(_v) = _t->width(); break;
        case 1: *reinterpret_cast< QCPBars**>(_v) = _t->barBelow(); break;
        case 2: *reinterpret_cast< QCPBars**>(_v) = _t->barAbove(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPBars *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setWidth(*reinterpret_cast< double*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
}

const QMetaObject *QCPBars::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPBars::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPBarsENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractPlottable::qt_metacast(_clname);
}

int QCPBars::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractPlottable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 3;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS = QtMocHelpers::stringData(
    "QCPStatisticalBox",
    "key",
    "minimum",
    "lowerQuartile",
    "median",
    "upperQuartile",
    "maximum",
    "outliers",
    "QList<double>",
    "width",
    "whiskerWidth",
    "whiskerPen",
    "whiskerBarPen",
    "medianPen",
    "outlierStyle",
    "QCPScatterStyle"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS_t {
    uint offsetsAndSizes[32];
    char stringdata0[18];
    char stringdata1[4];
    char stringdata2[8];
    char stringdata3[14];
    char stringdata4[7];
    char stringdata5[14];
    char stringdata6[8];
    char stringdata7[9];
    char stringdata8[14];
    char stringdata9[6];
    char stringdata10[13];
    char stringdata11[11];
    char stringdata12[14];
    char stringdata13[10];
    char stringdata14[13];
    char stringdata15[16];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS_t qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS = {
    {
        QT_MOC_LITERAL(0, 17),  // "QCPStatisticalBox"
        QT_MOC_LITERAL(18, 3),  // "key"
        QT_MOC_LITERAL(22, 7),  // "minimum"
        QT_MOC_LITERAL(30, 13),  // "lowerQuartile"
        QT_MOC_LITERAL(44, 6),  // "median"
        QT_MOC_LITERAL(51, 13),  // "upperQuartile"
        QT_MOC_LITERAL(65, 7),  // "maximum"
        QT_MOC_LITERAL(73, 8),  // "outliers"
        QT_MOC_LITERAL(82, 13),  // "QList<double>"
        QT_MOC_LITERAL(96, 5),  // "width"
        QT_MOC_LITERAL(102, 12),  // "whiskerWidth"
        QT_MOC_LITERAL(115, 10),  // "whiskerPen"
        QT_MOC_LITERAL(126, 13),  // "whiskerBarPen"
        QT_MOC_LITERAL(140, 9),  // "medianPen"
        QT_MOC_LITERAL(150, 12),  // "outlierStyle"
        QT_MOC_LITERAL(163, 15)   // "QCPScatterStyle"
    },
    "QCPStatisticalBox",
    "key",
    "minimum",
    "lowerQuartile",
    "median",
    "upperQuartile",
    "maximum",
    "outliers",
    "QList<double>",
    "width",
    "whiskerWidth",
    "whiskerPen",
    "whiskerBarPen",
    "medianPen",
    "outlierStyle",
    "QCPScatterStyle"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPStatisticalBoxENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
      13,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::Double, 0x00015103, uint(-1), 0,
       2, QMetaType::Double, 0x00015103, uint(-1), 0,
       3, QMetaType::Double, 0x00015103, uint(-1), 0,
       4, QMetaType::Double, 0x00015103, uint(-1), 0,
       5, QMetaType::Double, 0x00015103, uint(-1), 0,
       6, QMetaType::Double, 0x00015103, uint(-1), 0,
       7, 0x80000000 | 8, 0x0001510b, uint(-1), 0,
       9, QMetaType::Double, 0x00015103, uint(-1), 0,
      10, QMetaType::Double, 0x00015103, uint(-1), 0,
      11, QMetaType::QPen, 0x00015103, uint(-1), 0,
      12, QMetaType::QPen, 0x00015103, uint(-1), 0,
      13, QMetaType::QPen, 0x00015103, uint(-1), 0,
      14, 0x80000000 | 15, 0x0001510b, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPStatisticalBox::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractPlottable::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPStatisticalBoxENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS_t,
        // property 'key'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'minimum'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'lowerQuartile'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'median'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'upperQuartile'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'maximum'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'outliers'
        QtPrivate::TypeAndForceComplete<QList<double>, std::true_type>,
        // property 'width'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'whiskerWidth'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'whiskerPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'whiskerBarPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'medianPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'outlierStyle'
        QtPrivate::TypeAndForceComplete<QCPScatterStyle, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPStatisticalBox, std::true_type>
    >,
    nullptr
} };

void QCPStatisticalBox::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 6:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QList<double> >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPStatisticalBox *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< double*>(_v) = _t->key(); break;
        case 1: *reinterpret_cast< double*>(_v) = _t->minimum(); break;
        case 2: *reinterpret_cast< double*>(_v) = _t->lowerQuartile(); break;
        case 3: *reinterpret_cast< double*>(_v) = _t->median(); break;
        case 4: *reinterpret_cast< double*>(_v) = _t->upperQuartile(); break;
        case 5: *reinterpret_cast< double*>(_v) = _t->maximum(); break;
        case 6: *reinterpret_cast< QList<double>*>(_v) = _t->outliers(); break;
        case 7: *reinterpret_cast< double*>(_v) = _t->width(); break;
        case 8: *reinterpret_cast< double*>(_v) = _t->whiskerWidth(); break;
        case 9: *reinterpret_cast< QPen*>(_v) = _t->whiskerPen(); break;
        case 10: *reinterpret_cast< QPen*>(_v) = _t->whiskerBarPen(); break;
        case 11: *reinterpret_cast< QPen*>(_v) = _t->medianPen(); break;
        case 12: *reinterpret_cast< QCPScatterStyle*>(_v) = _t->outlierStyle(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPStatisticalBox *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setKey(*reinterpret_cast< double*>(_v)); break;
        case 1: _t->setMinimum(*reinterpret_cast< double*>(_v)); break;
        case 2: _t->setLowerQuartile(*reinterpret_cast< double*>(_v)); break;
        case 3: _t->setMedian(*reinterpret_cast< double*>(_v)); break;
        case 4: _t->setUpperQuartile(*reinterpret_cast< double*>(_v)); break;
        case 5: _t->setMaximum(*reinterpret_cast< double*>(_v)); break;
        case 6: _t->setOutliers(*reinterpret_cast< QList<double>*>(_v)); break;
        case 7: _t->setWidth(*reinterpret_cast< double*>(_v)); break;
        case 8: _t->setWhiskerWidth(*reinterpret_cast< double*>(_v)); break;
        case 9: _t->setWhiskerPen(*reinterpret_cast< QPen*>(_v)); break;
        case 10: _t->setWhiskerBarPen(*reinterpret_cast< QPen*>(_v)); break;
        case 11: _t->setMedianPen(*reinterpret_cast< QPen*>(_v)); break;
        case 12: _t->setOutlierStyle(*reinterpret_cast< QCPScatterStyle*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
}

const QMetaObject *QCPStatisticalBox::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPStatisticalBox::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPStatisticalBoxENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractPlottable::qt_metacast(_clname);
}

int QCPStatisticalBox::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractPlottable::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 13;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS = QtMocHelpers::stringData(
    "QCPItemStraightLine",
    "pen",
    "selectedPen"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS_t {
    uint offsetsAndSizes[6];
    char stringdata0[20];
    char stringdata1[4];
    char stringdata2[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS_t qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS = {
    {
        QT_MOC_LITERAL(0, 19),  // "QCPItemStraightLine"
        QT_MOC_LITERAL(20, 3),  // "pen"
        QT_MOC_LITERAL(24, 11)   // "selectedPen"
    },
    "QCPItemStraightLine",
    "pen",
    "selectedPen"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemStraightLineENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       2,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPen, 0x00015103, uint(-1), 0,
       2, QMetaType::QPen, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemStraightLine::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemStraightLineENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS_t,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemStraightLine, std::true_type>
    >,
    nullptr
} };

void QCPItemStraightLine::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemStraightLine *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 1: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemStraightLine *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 1: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPItemStraightLine::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemStraightLine::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemStraightLineENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemStraightLine::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 2;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemLineENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemLineENDCLASS = QtMocHelpers::stringData(
    "QCPItemLine",
    "pen",
    "selectedPen",
    "head",
    "QCPLineEnding",
    "tail"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemLineENDCLASS_t {
    uint offsetsAndSizes[12];
    char stringdata0[12];
    char stringdata1[4];
    char stringdata2[12];
    char stringdata3[5];
    char stringdata4[14];
    char stringdata5[5];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemLineENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemLineENDCLASS_t qt_meta_stringdata_CLASSQCPItemLineENDCLASS = {
    {
        QT_MOC_LITERAL(0, 11),  // "QCPItemLine"
        QT_MOC_LITERAL(12, 3),  // "pen"
        QT_MOC_LITERAL(16, 11),  // "selectedPen"
        QT_MOC_LITERAL(28, 4),  // "head"
        QT_MOC_LITERAL(33, 13),  // "QCPLineEnding"
        QT_MOC_LITERAL(47, 4)   // "tail"
    },
    "QCPItemLine",
    "pen",
    "selectedPen",
    "head",
    "QCPLineEnding",
    "tail"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemLineENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       4,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPen, 0x00015103, uint(-1), 0,
       2, QMetaType::QPen, 0x00015103, uint(-1), 0,
       3, 0x80000000 | 4, 0x0001510b, uint(-1), 0,
       5, 0x80000000 | 4, 0x0001510b, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemLine::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemLineENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemLineENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemLineENDCLASS_t,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'head'
        QtPrivate::TypeAndForceComplete<QCPLineEnding, std::true_type>,
        // property 'tail'
        QtPrivate::TypeAndForceComplete<QCPLineEnding, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemLine, std::true_type>
    >,
    nullptr
} };

void QCPItemLine::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemLine *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 1: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        case 2: *reinterpret_cast< QCPLineEnding*>(_v) = _t->head(); break;
        case 3: *reinterpret_cast< QCPLineEnding*>(_v) = _t->tail(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemLine *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 1: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        case 2: _t->setHead(*reinterpret_cast< QCPLineEnding*>(_v)); break;
        case 3: _t->setTail(*reinterpret_cast< QCPLineEnding*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPItemLine::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemLine::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemLineENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemLine::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemCurveENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemCurveENDCLASS = QtMocHelpers::stringData(
    "QCPItemCurve",
    "pen",
    "selectedPen",
    "head",
    "QCPLineEnding",
    "tail"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemCurveENDCLASS_t {
    uint offsetsAndSizes[12];
    char stringdata0[13];
    char stringdata1[4];
    char stringdata2[12];
    char stringdata3[5];
    char stringdata4[14];
    char stringdata5[5];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemCurveENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemCurveENDCLASS_t qt_meta_stringdata_CLASSQCPItemCurveENDCLASS = {
    {
        QT_MOC_LITERAL(0, 12),  // "QCPItemCurve"
        QT_MOC_LITERAL(13, 3),  // "pen"
        QT_MOC_LITERAL(17, 11),  // "selectedPen"
        QT_MOC_LITERAL(29, 4),  // "head"
        QT_MOC_LITERAL(34, 13),  // "QCPLineEnding"
        QT_MOC_LITERAL(48, 4)   // "tail"
    },
    "QCPItemCurve",
    "pen",
    "selectedPen",
    "head",
    "QCPLineEnding",
    "tail"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemCurveENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       4,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPen, 0x00015103, uint(-1), 0,
       2, QMetaType::QPen, 0x00015103, uint(-1), 0,
       3, 0x80000000 | 4, 0x0001510b, uint(-1), 0,
       5, 0x80000000 | 4, 0x0001510b, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemCurve::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemCurveENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemCurveENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemCurveENDCLASS_t,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'head'
        QtPrivate::TypeAndForceComplete<QCPLineEnding, std::true_type>,
        // property 'tail'
        QtPrivate::TypeAndForceComplete<QCPLineEnding, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemCurve, std::true_type>
    >,
    nullptr
} };

void QCPItemCurve::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemCurve *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 1: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        case 2: *reinterpret_cast< QCPLineEnding*>(_v) = _t->head(); break;
        case 3: *reinterpret_cast< QCPLineEnding*>(_v) = _t->tail(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemCurve *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 1: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        case 2: _t->setHead(*reinterpret_cast< QCPLineEnding*>(_v)); break;
        case 3: _t->setTail(*reinterpret_cast< QCPLineEnding*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPItemCurve::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemCurve::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemCurveENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemCurve::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemRectENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemRectENDCLASS = QtMocHelpers::stringData(
    "QCPItemRect",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemRectENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[12];
    char stringdata1[4];
    char stringdata2[12];
    char stringdata3[6];
    char stringdata4[14];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemRectENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemRectENDCLASS_t qt_meta_stringdata_CLASSQCPItemRectENDCLASS = {
    {
        QT_MOC_LITERAL(0, 11),  // "QCPItemRect"
        QT_MOC_LITERAL(12, 3),  // "pen"
        QT_MOC_LITERAL(16, 11),  // "selectedPen"
        QT_MOC_LITERAL(28, 5),  // "brush"
        QT_MOC_LITERAL(34, 13)   // "selectedBrush"
    },
    "QCPItemRect",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemRectENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       4,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPen, 0x00015103, uint(-1), 0,
       2, QMetaType::QPen, 0x00015103, uint(-1), 0,
       3, QMetaType::QBrush, 0x00015103, uint(-1), 0,
       4, QMetaType::QBrush, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemRect::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemRectENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemRectENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemRectENDCLASS_t,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'brush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'selectedBrush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemRect, std::true_type>
    >,
    nullptr
} };

void QCPItemRect::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemRect *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 1: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        case 2: *reinterpret_cast< QBrush*>(_v) = _t->brush(); break;
        case 3: *reinterpret_cast< QBrush*>(_v) = _t->selectedBrush(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemRect *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 1: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        case 2: _t->setBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 3: _t->setSelectedBrush(*reinterpret_cast< QBrush*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPItemRect::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemRect::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemRectENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemRect::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemTextENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemTextENDCLASS = QtMocHelpers::stringData(
    "QCPItemText",
    "color",
    "selectedColor",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush",
    "font",
    "selectedFont",
    "text",
    "positionAlignment",
    "Qt::Alignment",
    "textAlignment",
    "rotation",
    "padding",
    "QMargins"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemTextENDCLASS_t {
    uint offsetsAndSizes[32];
    char stringdata0[12];
    char stringdata1[6];
    char stringdata2[14];
    char stringdata3[4];
    char stringdata4[12];
    char stringdata5[6];
    char stringdata6[14];
    char stringdata7[5];
    char stringdata8[13];
    char stringdata9[5];
    char stringdata10[18];
    char stringdata11[14];
    char stringdata12[14];
    char stringdata13[9];
    char stringdata14[8];
    char stringdata15[9];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemTextENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemTextENDCLASS_t qt_meta_stringdata_CLASSQCPItemTextENDCLASS = {
    {
        QT_MOC_LITERAL(0, 11),  // "QCPItemText"
        QT_MOC_LITERAL(12, 5),  // "color"
        QT_MOC_LITERAL(18, 13),  // "selectedColor"
        QT_MOC_LITERAL(32, 3),  // "pen"
        QT_MOC_LITERAL(36, 11),  // "selectedPen"
        QT_MOC_LITERAL(48, 5),  // "brush"
        QT_MOC_LITERAL(54, 13),  // "selectedBrush"
        QT_MOC_LITERAL(68, 4),  // "font"
        QT_MOC_LITERAL(73, 12),  // "selectedFont"
        QT_MOC_LITERAL(86, 4),  // "text"
        QT_MOC_LITERAL(91, 17),  // "positionAlignment"
        QT_MOC_LITERAL(109, 13),  // "Qt::Alignment"
        QT_MOC_LITERAL(123, 13),  // "textAlignment"
        QT_MOC_LITERAL(137, 8),  // "rotation"
        QT_MOC_LITERAL(146, 7),  // "padding"
        QT_MOC_LITERAL(154, 8)   // "QMargins"
    },
    "QCPItemText",
    "color",
    "selectedColor",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush",
    "font",
    "selectedFont",
    "text",
    "positionAlignment",
    "Qt::Alignment",
    "textAlignment",
    "rotation",
    "padding",
    "QMargins"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemTextENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
      13,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QColor, 0x00015103, uint(-1), 0,
       2, QMetaType::QColor, 0x00015103, uint(-1), 0,
       3, QMetaType::QPen, 0x00015103, uint(-1), 0,
       4, QMetaType::QPen, 0x00015103, uint(-1), 0,
       5, QMetaType::QBrush, 0x00015103, uint(-1), 0,
       6, QMetaType::QBrush, 0x00015103, uint(-1), 0,
       7, QMetaType::QFont, 0x00015103, uint(-1), 0,
       8, QMetaType::QFont, 0x00015103, uint(-1), 0,
       9, QMetaType::QString, 0x00015103, uint(-1), 0,
      10, 0x80000000 | 11, 0x0001510b, uint(-1), 0,
      12, 0x80000000 | 11, 0x0001510b, uint(-1), 0,
      13, QMetaType::Double, 0x00015103, uint(-1), 0,
      14, 0x80000000 | 15, 0x0001510b, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemText::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemTextENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemTextENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemTextENDCLASS_t,
        // property 'color'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'selectedColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'brush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'selectedBrush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'font'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'selectedFont'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'text'
        QtPrivate::TypeAndForceComplete<QString, std::true_type>,
        // property 'positionAlignment'
        QtPrivate::TypeAndForceComplete<Qt::Alignment, std::true_type>,
        // property 'textAlignment'
        QtPrivate::TypeAndForceComplete<Qt::Alignment, std::true_type>,
        // property 'rotation'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'padding'
        QtPrivate::TypeAndForceComplete<QMargins, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemText, std::true_type>
    >,
    nullptr
} };

void QCPItemText::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemText *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QColor*>(_v) = _t->color(); break;
        case 1: *reinterpret_cast< QColor*>(_v) = _t->selectedColor(); break;
        case 2: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 3: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        case 4: *reinterpret_cast< QBrush*>(_v) = _t->brush(); break;
        case 5: *reinterpret_cast< QBrush*>(_v) = _t->selectedBrush(); break;
        case 6: *reinterpret_cast< QFont*>(_v) = _t->font(); break;
        case 7: *reinterpret_cast< QFont*>(_v) = _t->selectedFont(); break;
        case 8: *reinterpret_cast< QString*>(_v) = _t->text(); break;
        case 9: *reinterpret_cast< Qt::Alignment*>(_v) = _t->positionAlignment(); break;
        case 10: *reinterpret_cast< Qt::Alignment*>(_v) = _t->textAlignment(); break;
        case 11: *reinterpret_cast< double*>(_v) = _t->rotation(); break;
        case 12: *reinterpret_cast< QMargins*>(_v) = _t->padding(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemText *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setColor(*reinterpret_cast< QColor*>(_v)); break;
        case 1: _t->setSelectedColor(*reinterpret_cast< QColor*>(_v)); break;
        case 2: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 3: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        case 4: _t->setBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 5: _t->setSelectedBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 6: _t->setFont(*reinterpret_cast< QFont*>(_v)); break;
        case 7: _t->setSelectedFont(*reinterpret_cast< QFont*>(_v)); break;
        case 8: _t->setText(*reinterpret_cast< QString*>(_v)); break;
        case 9: _t->setPositionAlignment(*reinterpret_cast< Qt::Alignment*>(_v)); break;
        case 10: _t->setTextAlignment(*reinterpret_cast< Qt::Alignment*>(_v)); break;
        case 11: _t->setRotation(*reinterpret_cast< double*>(_v)); break;
        case 12: _t->setPadding(*reinterpret_cast< QMargins*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPItemText::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemText::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemTextENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemText::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 13;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS = QtMocHelpers::stringData(
    "QCPItemEllipse",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS_t {
    uint offsetsAndSizes[10];
    char stringdata0[15];
    char stringdata1[4];
    char stringdata2[12];
    char stringdata3[6];
    char stringdata4[14];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS_t qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS = {
    {
        QT_MOC_LITERAL(0, 14),  // "QCPItemEllipse"
        QT_MOC_LITERAL(15, 3),  // "pen"
        QT_MOC_LITERAL(19, 11),  // "selectedPen"
        QT_MOC_LITERAL(31, 5),  // "brush"
        QT_MOC_LITERAL(37, 13)   // "selectedBrush"
    },
    "QCPItemEllipse",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemEllipseENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       4,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPen, 0x00015103, uint(-1), 0,
       2, QMetaType::QPen, 0x00015103, uint(-1), 0,
       3, QMetaType::QBrush, 0x00015103, uint(-1), 0,
       4, QMetaType::QBrush, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemEllipse::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemEllipseENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS_t,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'brush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'selectedBrush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemEllipse, std::true_type>
    >,
    nullptr
} };

void QCPItemEllipse::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemEllipse *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 1: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        case 2: *reinterpret_cast< QBrush*>(_v) = _t->brush(); break;
        case 3: *reinterpret_cast< QBrush*>(_v) = _t->selectedBrush(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemEllipse *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 1: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        case 2: _t->setBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 3: _t->setSelectedBrush(*reinterpret_cast< QBrush*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPItemEllipse::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemEllipse::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemEllipseENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemEllipse::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS = QtMocHelpers::stringData(
    "QCPItemPixmap",
    "pixmap",
    "scaled",
    "aspectRatioMode",
    "Qt::AspectRatioMode",
    "pen",
    "selectedPen"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS_t {
    uint offsetsAndSizes[14];
    char stringdata0[14];
    char stringdata1[7];
    char stringdata2[7];
    char stringdata3[16];
    char stringdata4[20];
    char stringdata5[4];
    char stringdata6[12];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS_t qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS = {
    {
        QT_MOC_LITERAL(0, 13),  // "QCPItemPixmap"
        QT_MOC_LITERAL(14, 6),  // "pixmap"
        QT_MOC_LITERAL(21, 6),  // "scaled"
        QT_MOC_LITERAL(28, 15),  // "aspectRatioMode"
        QT_MOC_LITERAL(44, 19),  // "Qt::AspectRatioMode"
        QT_MOC_LITERAL(64, 3),  // "pen"
        QT_MOC_LITERAL(68, 11)   // "selectedPen"
    },
    "QCPItemPixmap",
    "pixmap",
    "scaled",
    "aspectRatioMode",
    "Qt::AspectRatioMode",
    "pen",
    "selectedPen"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemPixmapENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       5,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPixmap, 0x00015103, uint(-1), 0,
       2, QMetaType::Bool, 0x00015103, uint(-1), 0,
       3, 0x80000000 | 4, 0x00015009, uint(-1), 0,
       5, QMetaType::QPen, 0x00015103, uint(-1), 0,
       6, QMetaType::QPen, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemPixmap::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemPixmapENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS_t,
        // property 'pixmap'
        QtPrivate::TypeAndForceComplete<QPixmap, std::true_type>,
        // property 'scaled'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'aspectRatioMode'
        QtPrivate::TypeAndForceComplete<Qt::AspectRatioMode, std::true_type>,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemPixmap, std::true_type>
    >,
    nullptr
} };

void QCPItemPixmap::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemPixmap *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPixmap*>(_v) = _t->pixmap(); break;
        case 1: *reinterpret_cast< bool*>(_v) = _t->scaled(); break;
        case 2: *reinterpret_cast< Qt::AspectRatioMode*>(_v) = _t->aspectRatioMode(); break;
        case 3: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 4: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemPixmap *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setPixmap(*reinterpret_cast< QPixmap*>(_v)); break;
        case 1: _t->setScaled(*reinterpret_cast< bool*>(_v)); break;
        case 3: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 4: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPItemPixmap::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemPixmap::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemPixmapENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemPixmap::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemTracerENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemTracerENDCLASS = QtMocHelpers::stringData(
    "QCPItemTracer",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush",
    "size",
    "style",
    "TracerStyle",
    "graph",
    "QCPGraph*",
    "graphKey",
    "interpolating",
    "tsNone",
    "tsPlus",
    "tsCrosshair",
    "tsCircle",
    "tsSquare"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemTracerENDCLASS_t {
    uint offsetsAndSizes[34];
    char stringdata0[14];
    char stringdata1[4];
    char stringdata2[12];
    char stringdata3[6];
    char stringdata4[14];
    char stringdata5[5];
    char stringdata6[6];
    char stringdata7[12];
    char stringdata8[6];
    char stringdata9[10];
    char stringdata10[9];
    char stringdata11[14];
    char stringdata12[7];
    char stringdata13[7];
    char stringdata14[12];
    char stringdata15[9];
    char stringdata16[9];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemTracerENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemTracerENDCLASS_t qt_meta_stringdata_CLASSQCPItemTracerENDCLASS = {
    {
        QT_MOC_LITERAL(0, 13),  // "QCPItemTracer"
        QT_MOC_LITERAL(14, 3),  // "pen"
        QT_MOC_LITERAL(18, 11),  // "selectedPen"
        QT_MOC_LITERAL(30, 5),  // "brush"
        QT_MOC_LITERAL(36, 13),  // "selectedBrush"
        QT_MOC_LITERAL(50, 4),  // "size"
        QT_MOC_LITERAL(55, 5),  // "style"
        QT_MOC_LITERAL(61, 11),  // "TracerStyle"
        QT_MOC_LITERAL(73, 5),  // "graph"
        QT_MOC_LITERAL(79, 9),  // "QCPGraph*"
        QT_MOC_LITERAL(89, 8),  // "graphKey"
        QT_MOC_LITERAL(98, 13),  // "interpolating"
        QT_MOC_LITERAL(112, 6),  // "tsNone"
        QT_MOC_LITERAL(119, 6),  // "tsPlus"
        QT_MOC_LITERAL(126, 11),  // "tsCrosshair"
        QT_MOC_LITERAL(138, 8),  // "tsCircle"
        QT_MOC_LITERAL(147, 8)   // "tsSquare"
    },
    "QCPItemTracer",
    "pen",
    "selectedPen",
    "brush",
    "selectedBrush",
    "size",
    "style",
    "TracerStyle",
    "graph",
    "QCPGraph*",
    "graphKey",
    "interpolating",
    "tsNone",
    "tsPlus",
    "tsCrosshair",
    "tsCircle",
    "tsSquare"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemTracerENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       9,   14, // properties
       1,   59, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPen, 0x00015103, uint(-1), 0,
       2, QMetaType::QPen, 0x00015103, uint(-1), 0,
       3, QMetaType::QBrush, 0x00015103, uint(-1), 0,
       4, QMetaType::QBrush, 0x00015103, uint(-1), 0,
       5, QMetaType::Double, 0x00015103, uint(-1), 0,
       6, 0x80000000 | 7, 0x0001510b, uint(-1), 0,
       8, 0x80000000 | 9, 0x0001510b, uint(-1), 0,
      10, QMetaType::Double, 0x00015103, uint(-1), 0,
      11, QMetaType::Bool, 0x00015103, uint(-1), 0,

 // enums: name, alias, flags, count, data
       7,    7, 0x0,    5,   64,

 // enum data: key, value
      12, uint(QCPItemTracer::tsNone),
      13, uint(QCPItemTracer::tsPlus),
      14, uint(QCPItemTracer::tsCrosshair),
      15, uint(QCPItemTracer::tsCircle),
      16, uint(QCPItemTracer::tsSquare),

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemTracer::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemTracerENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemTracerENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemTracerENDCLASS_t,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'brush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'selectedBrush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'size'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'style'
        QtPrivate::TypeAndForceComplete<TracerStyle, std::true_type>,
        // property 'graph'
        QtPrivate::TypeAndForceComplete<QCPGraph*, std::true_type>,
        // property 'graphKey'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'interpolating'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemTracer, std::true_type>
    >,
    nullptr
} };

void QCPItemTracer::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 6:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPGraph* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemTracer *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 1: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        case 2: *reinterpret_cast< QBrush*>(_v) = _t->brush(); break;
        case 3: *reinterpret_cast< QBrush*>(_v) = _t->selectedBrush(); break;
        case 4: *reinterpret_cast< double*>(_v) = _t->size(); break;
        case 5: *reinterpret_cast< TracerStyle*>(_v) = _t->style(); break;
        case 6: *reinterpret_cast< QCPGraph**>(_v) = _t->graph(); break;
        case 7: *reinterpret_cast< double*>(_v) = _t->graphKey(); break;
        case 8: *reinterpret_cast< bool*>(_v) = _t->interpolating(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemTracer *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 1: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        case 2: _t->setBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 3: _t->setSelectedBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 4: _t->setSize(*reinterpret_cast< double*>(_v)); break;
        case 5: _t->setStyle(*reinterpret_cast< TracerStyle*>(_v)); break;
        case 6: _t->setGraph(*reinterpret_cast< QCPGraph**>(_v)); break;
        case 7: _t->setGraphKey(*reinterpret_cast< double*>(_v)); break;
        case 8: _t->setInterpolating(*reinterpret_cast< bool*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
}

const QMetaObject *QCPItemTracer::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemTracer::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemTracerENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemTracer::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 9;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPItemBracketENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPItemBracketENDCLASS = QtMocHelpers::stringData(
    "QCPItemBracket",
    "pen",
    "selectedPen",
    "length",
    "style",
    "BracketStyle"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPItemBracketENDCLASS_t {
    uint offsetsAndSizes[12];
    char stringdata0[15];
    char stringdata1[4];
    char stringdata2[12];
    char stringdata3[7];
    char stringdata4[6];
    char stringdata5[13];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPItemBracketENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPItemBracketENDCLASS_t qt_meta_stringdata_CLASSQCPItemBracketENDCLASS = {
    {
        QT_MOC_LITERAL(0, 14),  // "QCPItemBracket"
        QT_MOC_LITERAL(15, 3),  // "pen"
        QT_MOC_LITERAL(19, 11),  // "selectedPen"
        QT_MOC_LITERAL(31, 6),  // "length"
        QT_MOC_LITERAL(38, 5),  // "style"
        QT_MOC_LITERAL(44, 12)   // "BracketStyle"
    },
    "QCPItemBracket",
    "pen",
    "selectedPen",
    "length",
    "style",
    "BracketStyle"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPItemBracketENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       4,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPen, 0x00015103, uint(-1), 0,
       2, QMetaType::QPen, 0x00015103, uint(-1), 0,
       3, QMetaType::Double, 0x00015103, uint(-1), 0,
       4, 0x80000000 | 5, 0x0001510b, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPItemBracket::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPItemBracketENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPItemBracketENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPItemBracketENDCLASS_t,
        // property 'pen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'length'
        QtPrivate::TypeAndForceComplete<double, std::true_type>,
        // property 'style'
        QtPrivate::TypeAndForceComplete<BracketStyle, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPItemBracket, std::true_type>
    >,
    nullptr
} };

void QCPItemBracket::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPItemBracket *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPen*>(_v) = _t->pen(); break;
        case 1: *reinterpret_cast< QPen*>(_v) = _t->selectedPen(); break;
        case 2: *reinterpret_cast< double*>(_v) = _t->length(); break;
        case 3: *reinterpret_cast< BracketStyle*>(_v) = _t->style(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPItemBracket *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setPen(*reinterpret_cast< QPen*>(_v)); break;
        case 1: _t->setSelectedPen(*reinterpret_cast< QPen*>(_v)); break;
        case 2: _t->setLength(*reinterpret_cast< double*>(_v)); break;
        case 3: _t->setStyle(*reinterpret_cast< BracketStyle*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPItemBracket::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPItemBracket::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPItemBracketENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractItem::qt_metacast(_clname);
}

int QCPItemBracket::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractItem::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 4;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPAxisRectENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPAxisRectENDCLASS = QtMocHelpers::stringData(
    "QCPAxisRect",
    "background",
    "backgroundScaled",
    "backgroundScaledMode",
    "Qt::AspectRatioMode",
    "rangeDrag",
    "Qt::Orientations",
    "rangeZoom"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPAxisRectENDCLASS_t {
    uint offsetsAndSizes[16];
    char stringdata0[12];
    char stringdata1[11];
    char stringdata2[17];
    char stringdata3[21];
    char stringdata4[20];
    char stringdata5[10];
    char stringdata6[17];
    char stringdata7[10];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPAxisRectENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPAxisRectENDCLASS_t qt_meta_stringdata_CLASSQCPAxisRectENDCLASS = {
    {
        QT_MOC_LITERAL(0, 11),  // "QCPAxisRect"
        QT_MOC_LITERAL(12, 10),  // "background"
        QT_MOC_LITERAL(23, 16),  // "backgroundScaled"
        QT_MOC_LITERAL(40, 20),  // "backgroundScaledMode"
        QT_MOC_LITERAL(61, 19),  // "Qt::AspectRatioMode"
        QT_MOC_LITERAL(81, 9),  // "rangeDrag"
        QT_MOC_LITERAL(91, 16),  // "Qt::Orientations"
        QT_MOC_LITERAL(108, 9)   // "rangeZoom"
    },
    "QCPAxisRect",
    "background",
    "backgroundScaled",
    "backgroundScaledMode",
    "Qt::AspectRatioMode",
    "rangeDrag",
    "Qt::Orientations",
    "rangeZoom"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPAxisRectENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       5,   14, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

 // properties: name, type, flags
       1, QMetaType::QPixmap, 0x00015103, uint(-1), 0,
       2, QMetaType::Bool, 0x00015103, uint(-1), 0,
       3, 0x80000000 | 4, 0x0001510b, uint(-1), 0,
       5, 0x80000000 | 6, 0x0001510b, uint(-1), 0,
       7, 0x80000000 | 6, 0x0001510b, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPAxisRect::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayoutElement::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPAxisRectENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPAxisRectENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPAxisRectENDCLASS_t,
        // property 'background'
        QtPrivate::TypeAndForceComplete<QPixmap, std::true_type>,
        // property 'backgroundScaled'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'backgroundScaledMode'
        QtPrivate::TypeAndForceComplete<Qt::AspectRatioMode, std::true_type>,
        // property 'rangeDrag'
        QtPrivate::TypeAndForceComplete<Qt::Orientations, std::true_type>,
        // property 'rangeZoom'
        QtPrivate::TypeAndForceComplete<Qt::Orientations, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPAxisRect, std::true_type>
    >,
    nullptr
} };

void QCPAxisRect::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPAxisRect *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPixmap*>(_v) = _t->background(); break;
        case 1: *reinterpret_cast< bool*>(_v) = _t->backgroundScaled(); break;
        case 2: *reinterpret_cast< Qt::AspectRatioMode*>(_v) = _t->backgroundScaledMode(); break;
        case 3: *reinterpret_cast< Qt::Orientations*>(_v) = _t->rangeDrag(); break;
        case 4: *reinterpret_cast< Qt::Orientations*>(_v) = _t->rangeZoom(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPAxisRect *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setBackground(*reinterpret_cast< QPixmap*>(_v)); break;
        case 1: _t->setBackgroundScaled(*reinterpret_cast< bool*>(_v)); break;
        case 2: _t->setBackgroundScaledMode(*reinterpret_cast< Qt::AspectRatioMode*>(_v)); break;
        case 3: _t->setRangeDrag(*reinterpret_cast< Qt::Orientations*>(_v)); break;
        case 4: _t->setRangeZoom(*reinterpret_cast< Qt::Orientations*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPAxisRect::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPAxisRect::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPAxisRectENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayoutElement::qt_metacast(_clname);
}

int QCPAxisRect::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayoutElement::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    }
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS = QtMocHelpers::stringData(
    "QCPAbstractLegendItem",
    "selectionChanged",
    "",
    "selected",
    "parentLegend",
    "QCPLegend*",
    "font",
    "textColor",
    "selectedFont",
    "selectedTextColor",
    "selectable"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS_t {
    uint offsetsAndSizes[22];
    char stringdata0[22];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[9];
    char stringdata4[13];
    char stringdata5[11];
    char stringdata6[5];
    char stringdata7[10];
    char stringdata8[13];
    char stringdata9[18];
    char stringdata10[11];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS_t qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS = {
    {
        QT_MOC_LITERAL(0, 21),  // "QCPAbstractLegendItem"
        QT_MOC_LITERAL(22, 16),  // "selectionChanged"
        QT_MOC_LITERAL(39, 0),  // ""
        QT_MOC_LITERAL(40, 8),  // "selected"
        QT_MOC_LITERAL(49, 12),  // "parentLegend"
        QT_MOC_LITERAL(62, 10),  // "QCPLegend*"
        QT_MOC_LITERAL(73, 4),  // "font"
        QT_MOC_LITERAL(78, 9),  // "textColor"
        QT_MOC_LITERAL(88, 12),  // "selectedFont"
        QT_MOC_LITERAL(101, 17),  // "selectedTextColor"
        QT_MOC_LITERAL(119, 10)   // "selectable"
    },
    "QCPAbstractLegendItem",
    "selectionChanged",
    "",
    "selected",
    "parentLegend",
    "QCPLegend*",
    "font",
    "textColor",
    "selectedFont",
    "selectedTextColor",
    "selectable"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPAbstractLegendItemENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       7,   23, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x06,    8 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Bool,    3,

 // properties: name, type, flags
       4, 0x80000000 | 5, 0x00015009, uint(-1), 0,
       6, QMetaType::QFont, 0x00015103, uint(-1), 0,
       7, QMetaType::QColor, 0x00015103, uint(-1), 0,
       8, QMetaType::QFont, 0x00015103, uint(-1), 0,
       9, QMetaType::QColor, 0x00015103, uint(-1), 0,
      10, QMetaType::Bool, 0x00015103, uint(-1), 0,
       3, QMetaType::Bool, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPAbstractLegendItem::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayoutElement::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPAbstractLegendItemENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS_t,
        // property 'parentLegend'
        QtPrivate::TypeAndForceComplete<QCPLegend*, std::true_type>,
        // property 'font'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'textColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'selectedFont'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'selectedTextColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'selectable'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'selected'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPAbstractLegendItem, std::true_type>,
        // method 'selectionChanged'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>
    >,
    nullptr
} };

void QCPAbstractLegendItem::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<QCPAbstractLegendItem *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->selectionChanged((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (QCPAbstractLegendItem::*)(bool );
            if (_t _q_method = &QCPAbstractLegendItem::selectionChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    } else if (_c == QMetaObject::RegisterPropertyMetaType) {
        switch (_id) {
        default: *reinterpret_cast<int*>(_a[0]) = -1; break;
        case 0:
            *reinterpret_cast<int*>(_a[0]) = qRegisterMetaType< QCPLegend* >(); break;
        }
    } else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPAbstractLegendItem *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QCPLegend**>(_v) = _t->parentLegend(); break;
        case 1: *reinterpret_cast< QFont*>(_v) = _t->font(); break;
        case 2: *reinterpret_cast< QColor*>(_v) = _t->textColor(); break;
        case 3: *reinterpret_cast< QFont*>(_v) = _t->selectedFont(); break;
        case 4: *reinterpret_cast< QColor*>(_v) = _t->selectedTextColor(); break;
        case 5: *reinterpret_cast< bool*>(_v) = _t->selectable(); break;
        case 6: *reinterpret_cast< bool*>(_v) = _t->selected(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPAbstractLegendItem *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 1: _t->setFont(*reinterpret_cast< QFont*>(_v)); break;
        case 2: _t->setTextColor(*reinterpret_cast< QColor*>(_v)); break;
        case 3: _t->setSelectedFont(*reinterpret_cast< QFont*>(_v)); break;
        case 4: _t->setSelectedTextColor(*reinterpret_cast< QColor*>(_v)); break;
        case 5: _t->setSelectable(*reinterpret_cast< bool*>(_v)); break;
        case 6: _t->setSelected(*reinterpret_cast< bool*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
}

const QMetaObject *QCPAbstractLegendItem::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPAbstractLegendItem::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPAbstractLegendItemENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayoutElement::qt_metacast(_clname);
}

int QCPAbstractLegendItem::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayoutElement::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 7;
    }
    return _id;
}

// SIGNAL 0
void QCPAbstractLegendItem::selectionChanged(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS = QtMocHelpers::stringData(
    "QCPPlottableLegendItem"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS_t {
    uint offsetsAndSizes[2];
    char stringdata0[23];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS_t qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS = {
    {
        QT_MOC_LITERAL(0, 22)   // "QCPPlottableLegendItem"
    },
    "QCPPlottableLegendItem"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPPlottableLegendItemENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       0,    0, // methods
       0,    0, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       0,       // signalCount

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPPlottableLegendItem::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPAbstractLegendItem::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPPlottableLegendItemENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS_t,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPPlottableLegendItem, std::true_type>
    >,
    nullptr
} };

void QCPPlottableLegendItem::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    (void)_o;
    (void)_id;
    (void)_c;
    (void)_a;
}

const QMetaObject *QCPPlottableLegendItem::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPPlottableLegendItem::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPPlottableLegendItemENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPAbstractLegendItem::qt_metacast(_clname);
}

int QCPPlottableLegendItem::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPAbstractLegendItem::qt_metacall(_c, _id, _a);
    return _id;
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPLegendENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPLegendENDCLASS = QtMocHelpers::stringData(
    "QCPLegend",
    "selectionChanged",
    "",
    "QCPLegend::SelectableParts",
    "selection",
    "borderPen",
    "brush",
    "font",
    "textColor",
    "iconSize",
    "iconTextPadding",
    "iconBorderPen",
    "selectableParts",
    "SelectableParts",
    "selectedParts",
    "selectedBorderPen",
    "selectedIconBorderPen",
    "selectedBrush",
    "selectedFont",
    "selectedTextColor",
    "SelectablePart",
    "spNone",
    "spLegendBox",
    "spItems"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPLegendENDCLASS_t {
    uint offsetsAndSizes[48];
    char stringdata0[10];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[27];
    char stringdata4[10];
    char stringdata5[10];
    char stringdata6[6];
    char stringdata7[5];
    char stringdata8[10];
    char stringdata9[9];
    char stringdata10[16];
    char stringdata11[14];
    char stringdata12[16];
    char stringdata13[16];
    char stringdata14[14];
    char stringdata15[18];
    char stringdata16[22];
    char stringdata17[14];
    char stringdata18[13];
    char stringdata19[18];
    char stringdata20[15];
    char stringdata21[7];
    char stringdata22[12];
    char stringdata23[8];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPLegendENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPLegendENDCLASS_t qt_meta_stringdata_CLASSQCPLegendENDCLASS = {
    {
        QT_MOC_LITERAL(0, 9),  // "QCPLegend"
        QT_MOC_LITERAL(10, 16),  // "selectionChanged"
        QT_MOC_LITERAL(27, 0),  // ""
        QT_MOC_LITERAL(28, 26),  // "QCPLegend::SelectableParts"
        QT_MOC_LITERAL(55, 9),  // "selection"
        QT_MOC_LITERAL(65, 9),  // "borderPen"
        QT_MOC_LITERAL(75, 5),  // "brush"
        QT_MOC_LITERAL(81, 4),  // "font"
        QT_MOC_LITERAL(86, 9),  // "textColor"
        QT_MOC_LITERAL(96, 8),  // "iconSize"
        QT_MOC_LITERAL(105, 15),  // "iconTextPadding"
        QT_MOC_LITERAL(121, 13),  // "iconBorderPen"
        QT_MOC_LITERAL(135, 15),  // "selectableParts"
        QT_MOC_LITERAL(151, 15),  // "SelectableParts"
        QT_MOC_LITERAL(167, 13),  // "selectedParts"
        QT_MOC_LITERAL(181, 17),  // "selectedBorderPen"
        QT_MOC_LITERAL(199, 21),  // "selectedIconBorderPen"
        QT_MOC_LITERAL(221, 13),  // "selectedBrush"
        QT_MOC_LITERAL(235, 12),  // "selectedFont"
        QT_MOC_LITERAL(248, 17),  // "selectedTextColor"
        QT_MOC_LITERAL(266, 14),  // "SelectablePart"
        QT_MOC_LITERAL(281, 6),  // "spNone"
        QT_MOC_LITERAL(288, 11),  // "spLegendBox"
        QT_MOC_LITERAL(300, 7)   // "spItems"
    },
    "QCPLegend",
    "selectionChanged",
    "",
    "QCPLegend::SelectableParts",
    "selection",
    "borderPen",
    "brush",
    "font",
    "textColor",
    "iconSize",
    "iconTextPadding",
    "iconBorderPen",
    "selectableParts",
    "SelectableParts",
    "selectedParts",
    "selectedBorderPen",
    "selectedIconBorderPen",
    "selectedBrush",
    "selectedFont",
    "selectedTextColor",
    "SelectablePart",
    "spNone",
    "spLegendBox",
    "spItems"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPLegendENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
      14,   23, // properties
       2,   93, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x06,   15 /* Public */,

 // signals: parameters
    QMetaType::Void, 0x80000000 | 3,    4,

 // properties: name, type, flags
       5, QMetaType::QPen, 0x00015103, uint(-1), 0,
       6, QMetaType::QBrush, 0x00015103, uint(-1), 0,
       7, QMetaType::QFont, 0x00015103, uint(-1), 0,
       8, QMetaType::QColor, 0x00015103, uint(-1), 0,
       9, QMetaType::QSize, 0x00015103, uint(-1), 0,
      10, QMetaType::Int, 0x00015103, uint(-1), 0,
      11, QMetaType::QPen, 0x00015103, uint(-1), 0,
      12, 0x80000000 | 13, 0x0001510b, uint(-1), 0,
      14, 0x80000000 | 13, 0x0001510b, uint(-1), 0,
      15, QMetaType::QPen, 0x00015103, uint(-1), 0,
      16, QMetaType::QPen, 0x00015103, uint(-1), 0,
      17, QMetaType::QBrush, 0x00015103, uint(-1), 0,
      18, QMetaType::QFont, 0x00015103, uint(-1), 0,
      19, QMetaType::QColor, 0x00015103, uint(-1), 0,

 // enums: name, alias, flags, count, data
      20,   20, 0x1,    3,  103,
      13,   20, 0x1,    3,  109,

 // enum data: key, value
      21, uint(QCPLegend::spNone),
      22, uint(QCPLegend::spLegendBox),
      23, uint(QCPLegend::spItems),
      21, uint(QCPLegend::spNone),
      22, uint(QCPLegend::spLegendBox),
      23, uint(QCPLegend::spItems),

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPLegend::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayoutGrid::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPLegendENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPLegendENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPLegendENDCLASS_t,
        // property 'borderPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'brush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'font'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'textColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'iconSize'
        QtPrivate::TypeAndForceComplete<QSize, std::true_type>,
        // property 'iconTextPadding'
        QtPrivate::TypeAndForceComplete<int, std::true_type>,
        // property 'iconBorderPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectableParts'
        QtPrivate::TypeAndForceComplete<SelectableParts, std::true_type>,
        // property 'selectedParts'
        QtPrivate::TypeAndForceComplete<SelectableParts, std::true_type>,
        // property 'selectedBorderPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedIconBorderPen'
        QtPrivate::TypeAndForceComplete<QPen, std::true_type>,
        // property 'selectedBrush'
        QtPrivate::TypeAndForceComplete<QBrush, std::true_type>,
        // property 'selectedFont'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'selectedTextColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPLegend, std::true_type>,
        // method 'selectionChanged'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<QCPLegend::SelectableParts, std::false_type>
    >,
    nullptr
} };

void QCPLegend::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<QCPLegend *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->selectionChanged((*reinterpret_cast< std::add_pointer_t<QCPLegend::SelectableParts>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (QCPLegend::*)(QCPLegend::SelectableParts );
            if (_t _q_method = &QCPLegend::selectionChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPLegend *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QPen*>(_v) = _t->borderPen(); break;
        case 1: *reinterpret_cast< QBrush*>(_v) = _t->brush(); break;
        case 2: *reinterpret_cast< QFont*>(_v) = _t->font(); break;
        case 3: *reinterpret_cast< QColor*>(_v) = _t->textColor(); break;
        case 4: *reinterpret_cast< QSize*>(_v) = _t->iconSize(); break;
        case 5: *reinterpret_cast< int*>(_v) = _t->iconTextPadding(); break;
        case 6: *reinterpret_cast< QPen*>(_v) = _t->iconBorderPen(); break;
        case 7: *reinterpret_cast<int*>(_v) = QFlag(_t->selectableParts()); break;
        case 8: *reinterpret_cast<int*>(_v) = QFlag(_t->selectedParts()); break;
        case 9: *reinterpret_cast< QPen*>(_v) = _t->selectedBorderPen(); break;
        case 10: *reinterpret_cast< QPen*>(_v) = _t->selectedIconBorderPen(); break;
        case 11: *reinterpret_cast< QBrush*>(_v) = _t->selectedBrush(); break;
        case 12: *reinterpret_cast< QFont*>(_v) = _t->selectedFont(); break;
        case 13: *reinterpret_cast< QColor*>(_v) = _t->selectedTextColor(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPLegend *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setBorderPen(*reinterpret_cast< QPen*>(_v)); break;
        case 1: _t->setBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 2: _t->setFont(*reinterpret_cast< QFont*>(_v)); break;
        case 3: _t->setTextColor(*reinterpret_cast< QColor*>(_v)); break;
        case 4: _t->setIconSize(*reinterpret_cast< QSize*>(_v)); break;
        case 5: _t->setIconTextPadding(*reinterpret_cast< int*>(_v)); break;
        case 6: _t->setIconBorderPen(*reinterpret_cast< QPen*>(_v)); break;
        case 7: _t->setSelectableParts(QFlag(*reinterpret_cast<int*>(_v))); break;
        case 8: _t->setSelectedParts(QFlag(*reinterpret_cast<int*>(_v))); break;
        case 9: _t->setSelectedBorderPen(*reinterpret_cast< QPen*>(_v)); break;
        case 10: _t->setSelectedIconBorderPen(*reinterpret_cast< QPen*>(_v)); break;
        case 11: _t->setSelectedBrush(*reinterpret_cast< QBrush*>(_v)); break;
        case 12: _t->setSelectedFont(*reinterpret_cast< QFont*>(_v)); break;
        case 13: _t->setSelectedTextColor(*reinterpret_cast< QColor*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
}

const QMetaObject *QCPLegend::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPLegend::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPLegendENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayoutGrid::qt_metacast(_clname);
}

int QCPLegend::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayoutGrid::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 14;
    }
    return _id;
}

// SIGNAL 0
void QCPLegend::selectionChanged(QCPLegend::SelectableParts _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
namespace {

#ifdef QT_MOC_HAS_STRINGDATA
struct qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS_t {};
static constexpr auto qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS = QtMocHelpers::stringData(
    "QCPPlotTitle",
    "selectionChanged",
    "",
    "selected",
    "text",
    "font",
    "textColor",
    "selectedFont",
    "selectedTextColor",
    "selectable"
);
#else  // !QT_MOC_HAS_STRING_DATA
struct qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS_t {
    uint offsetsAndSizes[20];
    char stringdata0[13];
    char stringdata1[17];
    char stringdata2[1];
    char stringdata3[9];
    char stringdata4[5];
    char stringdata5[5];
    char stringdata6[10];
    char stringdata7[13];
    char stringdata8[18];
    char stringdata9[11];
};
#define QT_MOC_LITERAL(ofs, len) \
    uint(sizeof(qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS_t::offsetsAndSizes) + ofs), len 
Q_CONSTINIT static const qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS_t qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS = {
    {
        QT_MOC_LITERAL(0, 12),  // "QCPPlotTitle"
        QT_MOC_LITERAL(13, 16),  // "selectionChanged"
        QT_MOC_LITERAL(30, 0),  // ""
        QT_MOC_LITERAL(31, 8),  // "selected"
        QT_MOC_LITERAL(40, 4),  // "text"
        QT_MOC_LITERAL(45, 4),  // "font"
        QT_MOC_LITERAL(50, 9),  // "textColor"
        QT_MOC_LITERAL(60, 12),  // "selectedFont"
        QT_MOC_LITERAL(73, 17),  // "selectedTextColor"
        QT_MOC_LITERAL(91, 10)   // "selectable"
    },
    "QCPPlotTitle",
    "selectionChanged",
    "",
    "selected",
    "text",
    "font",
    "textColor",
    "selectedFont",
    "selectedTextColor",
    "selectable"
};
#undef QT_MOC_LITERAL
#endif // !QT_MOC_HAS_STRING_DATA
} // unnamed namespace

Q_CONSTINIT static const uint qt_meta_data_CLASSQCPPlotTitleENDCLASS[] = {

 // content:
      11,       // revision
       0,       // classname
       0,    0, // classinfo
       1,   14, // methods
       7,   23, // properties
       0,    0, // enums/sets
       0,    0, // constructors
       0,       // flags
       1,       // signalCount

 // signals: name, argc, parameters, tag, flags, initial metatype offsets
       1,    1,   20,    2, 0x06,    8 /* Public */,

 // signals: parameters
    QMetaType::Void, QMetaType::Bool,    3,

 // properties: name, type, flags
       4, QMetaType::QString, 0x00015103, uint(-1), 0,
       5, QMetaType::QFont, 0x00015103, uint(-1), 0,
       6, QMetaType::QColor, 0x00015103, uint(-1), 0,
       7, QMetaType::QFont, 0x00015103, uint(-1), 0,
       8, QMetaType::QColor, 0x00015103, uint(-1), 0,
       9, QMetaType::Bool, 0x00015103, uint(-1), 0,
       3, QMetaType::Bool, 0x00015103, uint(-1), 0,

       0        // eod
};

Q_CONSTINIT const QMetaObject QCPPlotTitle::staticMetaObject = { {
    QMetaObject::SuperData::link<QCPLayoutElement::staticMetaObject>(),
    qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS.offsetsAndSizes,
    qt_meta_data_CLASSQCPPlotTitleENDCLASS,
    qt_static_metacall,
    nullptr,
    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS_t,
        // property 'text'
        QtPrivate::TypeAndForceComplete<QString, std::true_type>,
        // property 'font'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'textColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'selectedFont'
        QtPrivate::TypeAndForceComplete<QFont, std::true_type>,
        // property 'selectedTextColor'
        QtPrivate::TypeAndForceComplete<QColor, std::true_type>,
        // property 'selectable'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // property 'selected'
        QtPrivate::TypeAndForceComplete<bool, std::true_type>,
        // Q_OBJECT / Q_GADGET
        QtPrivate::TypeAndForceComplete<QCPPlotTitle, std::true_type>,
        // method 'selectionChanged'
        QtPrivate::TypeAndForceComplete<void, std::false_type>,
        QtPrivate::TypeAndForceComplete<bool, std::false_type>
    >,
    nullptr
} };

void QCPPlotTitle::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<QCPPlotTitle *>(_o);
        (void)_t;
        switch (_id) {
        case 0: _t->selectionChanged((*reinterpret_cast< std::add_pointer_t<bool>>(_a[1]))); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (QCPPlotTitle::*)(bool );
            if (_t _q_method = &QCPPlotTitle::selectionChanged; *reinterpret_cast<_t *>(_a[1]) == _q_method) {
                *result = 0;
                return;
            }
        }
    }else if (_c == QMetaObject::ReadProperty) {
        auto *_t = static_cast<QCPPlotTitle *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QString*>(_v) = _t->text(); break;
        case 1: *reinterpret_cast< QFont*>(_v) = _t->font(); break;
        case 2: *reinterpret_cast< QColor*>(_v) = _t->textColor(); break;
        case 3: *reinterpret_cast< QFont*>(_v) = _t->selectedFont(); break;
        case 4: *reinterpret_cast< QColor*>(_v) = _t->selectedTextColor(); break;
        case 5: *reinterpret_cast< bool*>(_v) = _t->selectable(); break;
        case 6: *reinterpret_cast< bool*>(_v) = _t->selected(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        auto *_t = static_cast<QCPPlotTitle *>(_o);
        (void)_t;
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setText(*reinterpret_cast< QString*>(_v)); break;
        case 1: _t->setFont(*reinterpret_cast< QFont*>(_v)); break;
        case 2: _t->setTextColor(*reinterpret_cast< QColor*>(_v)); break;
        case 3: _t->setSelectedFont(*reinterpret_cast< QFont*>(_v)); break;
        case 4: _t->setSelectedTextColor(*reinterpret_cast< QColor*>(_v)); break;
        case 5: _t->setSelectable(*reinterpret_cast< bool*>(_v)); break;
        case 6: _t->setSelected(*reinterpret_cast< bool*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    } else if (_c == QMetaObject::BindableProperty) {
    }
}

const QMetaObject *QCPPlotTitle::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *QCPPlotTitle::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_CLASSQCPPlotTitleENDCLASS.stringdata0))
        return static_cast<void*>(this);
    return QCPLayoutElement::qt_metacast(_clname);
}

int QCPPlotTitle::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QCPLayoutElement::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();
        _id -= 1;
    }else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::BindableProperty
            || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 7;
    }
    return _id;
}

// SIGNAL 0
void QCPPlotTitle::selectionChanged(bool _t1)
{
    void *_a[] = { nullptr, const_cast<void*>(reinterpret_cast<const void*>(std::addressof(_t1))) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}
QT_WARNING_POP
